CLASS ZCL_SDSSD_ETAX_INTERFACE DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF TS_DEFT_BUPLA,
        BUPLA TYPE VBRK-BUPLA,
        VTWEG TYPE RANGE OF VBRK-VTWEG,
      END OF TS_DEFT_BUPLA .
    TYPES:
      TT_DEFT_BUPLA TYPE SORTED TABLE OF TS_DEFT_BUPLA
                                    WITH UNIQUE KEY BUPLA .
    TYPES:
      TT_KSCHL_RANGE  TYPE  RANGE OF KONP-KSCHL .
    TYPES:
      TT_DATUM_RANGE  TYPE  RANGE OF SY-DATUM .
    TYPES:
      TT_XBLNR_RANGE  TYPE  RANGE OF VBRK-XBLNR .
    TYPES:
      TS_XBLNR_RANGE  TYPE LINE OF TT_XBLNR_RANGE .
    TYPES:
      TT_MATNR_RANGE TYPE RANGE OF VBAP-MATNR .
    TYPES:
      TT_KALSM_RANGE TYPE RANGE OF VBRK-KALSM .
    TYPES:
      TT_UMSKZ_RANGE TYPE RANGE OF BSEG-UMSKZ .
    TYPES:
      TT_BLART_RANGE TYPE RANGE OF BKPF-BLART .
    TYPES:
      TT_ZUONR_RANGE TYPE RANGE OF BSEG-ZUONR .
    TYPES:
      BEGIN OF TS_BILL,
        VBELN      TYPE VBRK-VBELN,
        BUKRS      TYPE VBRK-BUKRS,
        BELNR      TYPE VBRK-BELNR,
        GJAHR      TYPE VBRK-GJAHR,
        FKDAT      TYPE VBRK-FKDAT,
        KALSM      TYPE VBRK-KALSM,
        VBTYP      TYPE VBRK-VBTYP,
        FKART      TYPE VBRK-FKART,
        FKART_TXT  TYPE TVFKT-VTEXT,
        VTWEG      TYPE VBRK-VTWEG,
        BUPLA      TYPE VBRK-BUPLA,
        KUNNR      TYPE VBRK-KUNRG,
        XBLNR      TYPE VBRK-XBLNR,
        ZTERM      TYPE VBRK-ZTERM,
        ZTERM_TXT  TYPE TVZBT-VTEXT,
        INCO1      TYPE VBRK-INCO1,
        SFAKN      TYPE VBRK-SFAKN,
        ERNAM      TYPE VBRK-ERNAM,
        ERDAT      TYPE VBRK-ERDAT,
        AEDAT      TYPE VBRK-AEDAT,
        WAERS      TYPE VBRK-WAERK,
        NETWR      TYPE VBRK-NETWR,
        MWSBK      TYPE VBRK-MWSBK,
        KNUMV      TYPE VBRK-KNUMV,
*       Cancellation Fields
        CANC_VBELN TYPE  VBRK-VBELN,
        CANC_XBLNR TYPE  VBRK-XBLNR,
        CANC_FKDAT TYPE  VBRK-FKDAT,
        CANC_DOCTY TYPE  ZSDSSDC017-DOCTY,
*       RD Mapping Fields
        DOCTY      TYPE ZSDSSDC017-DOCTY,
        DESCP_TH   TYPE ZSDSSDC014-DESCP_TH,
        DESCP_EN   TYPE ZSDSSDC014-DESCP_EN,
        DCGRP      TYPE ZSDSSDC014-DCGRP,
      END OF TS_BILL .
    TYPES:
      TT_BILL TYPE SORTED TABLE OF TS_BILL
                                            WITH UNIQUE KEY VBELN .
    TYPES:
      BEGIN OF TS_BILL_ITEM,
        VBELN    TYPE  VBRP-VBELN,
        POSNR    TYPE  VBRP-POSNR,
        UEPOS    TYPE  VBRP-UEPOS,
        MATNR    TYPE  VBRP-MATNR,
        ARKTX    TYPE  VBRP-ARKTX,
        FKIMG    TYPE  VBRP-FKIMG,
        VRKME    TYPE  VBRP-VRKME,
        MWSK1    TYPE  VBRP-MWSK1,
        MWSKZ    TYPE  VBRP-MWSKZ,
        AUGRU    TYPE  VBRP-AUGRU_AUFT,
        AUGRU_TX TYPE TVAUT-BEZEI,
        AUBEL    TYPE  VBRP-AUBEL,
        AUPOS    TYPE  VBRP-AUPOS,
        KZWI1    TYPE  VBRP-KZWI1,
        KZWI2    TYPE  VBRP-KZWI2,
        KZWI3    TYPE  VBRP-KZWI3,
        KZWI4    TYPE  VBRP-KZWI4,
        KZWI5    TYPE  VBRP-KZWI5,
        MWSBP    TYPE  VBRP-MWSBP,
        NETWR    TYPE  VBRP-NETWR,
        BSTKD    TYPE  VBKD-BSTKD,
        BSTDK    TYPE  VBKD-BSTDK,
        AUDAT    TYPE  VBAK-AUDAT,
        TAXTY    TYPE  ZSDSSDC021-TAXTY,
      END OF TS_BILL_ITEM .
    TYPES:
      TT_BILL_ITEM TYPE SORTED TABLE OF TS_BILL_ITEM
                                                 WITH UNIQUE KEY VBELN
                                                                 POSNR .
    TYPES:
      BEGIN OF TS_BILL_PRICE,
        VBELN    TYPE  VBRK-VBELN,
        KPOSN    TYPE  PRCD_ELEMENTS-KPOSN,
        STUNR    TYPE  PRCD_ELEMENTS-STUNR,
        ZAEHK    TYPE  PRCD_ELEMENTS-ZAEHK,
        KSCHL    TYPE  PRCD_ELEMENTS-KSCHL,
        WAERS    TYPE  PRCD_ELEMENTS-WAERS,
        KBETR    TYPE  PRCD_ELEMENTS-KBETR,
        WAERK    TYPE  PRCD_ELEMENTS-WAERK,
        KWERT    TYPE  PRCD_ELEMENTS-KWERT,
*        RD Mapping Fields
        DISC_CD  TYPE  ZSDSSDC016-DISC_CD,
        DESCP_TH TYPE  ZSDSSDC016-DESCP_TH,
        DESCP_EN TYPE  ZSDSSDC016-DESCP_EN,
      END OF TS_BILL_PRICE .
    TYPES:
      TT_BILL_PRICE TYPE SORTED TABLE OF TS_BILL_PRICE
                                                   WITH UNIQUE KEY VBELN
                                                                   KPOSN
                                                                   STUNR
                                                                   ZAEHK .
    TYPES:
      BEGIN OF TS_FORMFILE,
        BUKRS      TYPE  ZSDSSDT021-BUKRS,
        GJAHR      TYPE  ZSDSSDT021-GJAHR,
        DOCTY      TYPE  ZSDSSDT021-DOCTY,
        TAXINV     TYPE  ZSDSSDT021-TAXINV,
        FORM_FNAME TYPE  STRING,
        AEDAT      TYPE  SY-DATUM,
        AEZET      TYPE  SY-UZEIT,
        LANGU      TYPE  CHAR2,
      END OF TS_FORMFILE .
    TYPES:
      TT_FORMFILE TYPE SORTED TABLE OF TS_FORMFILE
                                                        WITH UNIQUE KEY BUKRS
                                                                        GJAHR
                                                                        DOCTY
                                                                        TAXINV .
    TYPES:
      BEGIN OF TS_ETAX_LOG,
        BUKRS   TYPE ZSDSSDT021-BUKRS,
        DOCTY   TYPE ZSDSSDT021-DOCTY,
        TAXINV  TYPE ZSDSSDT021-TAXINV,
        SEQNO   TYPE ZSDSSDT021-SEQNO,
        VBELN   TYPE ZSDSSDT021-VBELN,
        BELNR   TYPE ZSDSSDT021-BELNR,
        GJAHR   TYPE ZSDSSDT021-GJAHR,
        CANCEL  TYPE ZSDSSDT021-CANCEL,
        USNAM   TYPE ZSDSSDT021-USNAM,
        STDAT   TYPE ZSDSSDT021-STDAT,
        STTIM   TYPE ZSDSSDT021-STTIM,
        ENDAT   TYPE ZSDSSDT021-ENDAT,
        ENTIM   TYPE ZSDSSDT021-ENTIM,
        STATUS  TYPE ZSDSSDT021-STATUS,
        MESSAGE TYPE ZSDSSDT021-MESSAGE,
      END OF TS_ETAX_LOG .
    TYPES:
      TT_ETAX_LOG  TYPE  STANDARD TABLE OF TS_ETAX_LOG
                                                  WITH DEFAULT KEY .
    TYPES:
      BEGIN OF TS_KEY,
        BUKRS  TYPE  ZSDSSDT021-BUKRS,
        DOCTY  TYPE  ZSDSSDT021-DOCTY,
        TAXINV TYPE  ZSDSSDT021-TAXINV,
      END OF TS_KEY .
    TYPES:
      TT_KEY TYPE SORTED TABLE OF TS_KEY
                                               WITH UNIQUE KEY BUKRS
                                                               DOCTY
                                                               TAXINV .
    TYPES:
      BEGIN OF TS_INTF_FORM,
        SAP_MODULE TYPE  ZSDSDE_ETAX_MODULE,
        INTFNO     TYPE ZSDSCAC004-INTFNO,
      END OF TS_INTF_FORM .
    TYPES:
      TT_INTF_FORM TYPE SORTED TABLE OF TS_INTF_FORM
                                                         WITH UNIQUE KEY SAP_MODULE
                                                                         INTFNO .
    TYPES:
      BEGIN OF TS_RD_ADDR,
        BUILDINGNUMBER       TYPE ZSDSSDS072-BUILDINGNUMBER,
        COUNTRYSUBDIVISIONID TYPE ZSDSSDS072-COUNTRYSUBDIVISIONID,
        CITYNAME             TYPE ZSDSSDS072-CITYNAME,
        CITYSUBDIVISIONNAME  TYPE ZSDSSDS072-CITYSUBDIVISIONNAME,
      END OF TS_RD_ADDR .
    TYPES:
      BEGIN OF TS_COMPANY,
        BUKRS TYPE  T001-BUKRS,
        BUTXT TYPE  T001-BUTXT,
        STCEG TYPE  T001-STCEG,
        ADRC  TYPE  ADRC,
        ADDIT TYPE  TS_RD_ADDR,
      END OF TS_COMPANY .
    TYPES:
      BEGIN OF TS_CUSTOMER_ETAX,
        REQ_SEND_SMS  TYPE ZSDSSDS061-REQ_SEND_SMS,
        MOBILE_NUMBER TYPE ZSDSSDS061-MOBILE_NUMBER,
        REQ_SEND_MAIL TYPE ZSDSSDS061-REQ_SEND_MAIL,
        EMAIL         TYPE ZSDSSDS061-EMAIL,
      END OF TS_CUSTOMER_ETAX .
    TYPES:
      BEGIN OF TS_CUSTOMER,
        KUNNR       TYPE  KNA1-KUNNR,
        NAME1       TYPE  KNA1-NAME1,
        NAME2       TYPE  KNA1-NAME2,
        STCD3       TYPE  KNA1-STCD3,
        J_1TPBUPL   TYPE  FITHA_PBUPL_D-J_1TPBUPL,
        DESCRIPTION TYPE  FITHA_PBUPL_D_T-DESCRIPTION,
        EMAIL       TYPE  ADR6-SMTP_ADDR,
        ADRC        TYPE  ADRC,
        ETAX        TYPE  TS_CUSTOMER_ETAX,
      END OF TS_CUSTOMER .
    TYPES TS_EXCH_CONTEXT TYPE ZSDSSDS063 .
    TYPES:
      BEGIN OF TS_CHRG_AMT,
        CHRG_IND TYPE CHAR1,
        DISC_CD  TYPE ZSDSDE_ETAX_DISC_CD,
        DESCP_TH TYPE ZSDSDE_ETAX_DESCP_TH,
        DESCP_EN TYPE ZSDSDE_ETAX_DESCP_EN,
        CHRG_AMT TYPE NETWR,
      END OF TS_CHRG_AMT .
    TYPES:
      TT_CHRG_AMT TYPE STANDARD TABLE OF TS_CHRG_AMT
                                                                WITH DEFAULT KEY .
    TYPES:
      BEGIN OF TS_ETAX_ITEM,
        ID        TYPE  I,
        POSNR     TYPE  VBRP-POSNR,
        MATNR     TYPE  VBRP-MATNR,
        DESCP     TYPE  TEXT1000,
        FKIMG     TYPE  VBRP-FKIMG,
        VRKME     TYPE  VBRP-VRKME,
        WAERS     TYPE  VBRK-WAERK,
        GROSS_AMT TYPE  NETWR,
        CHRG_AMT  TYPE  NETWR,
        ALLW_AMT  TYPE  NETWR,
        VATBS_AMT TYPE  NETWR,
        NET1_AMT  TYPE  NETWR,
        VAT_AMT   TYPE  NETWR,
        NET2_AMT  TYPE  NETWR,
        TAXTY     TYPE  ZSDSDE_ETAX_TAXTY,
        TAXRATE   TYPE  P LENGTH 4 DECIMALS 2,
*       Charge detail
        CHRG_TAB  TYPE  TT_CHRG_AMT,
      END OF TS_ETAX_ITEM .
    TYPES:
      TT_ETAX_ITEM TYPE STANDARD TABLE OF TS_ETAX_ITEM
                                                            WITH DEFAULT KEY .
    TYPES:
      BEGIN OF TS_ETAX_DATA,
*       Key Fields
        BUKRS      TYPE  VBRK-BUKRS,
        GJAHR      TYPE  VBRK-GJAHR,
        DOCTY      TYPE  ZSDSDE_ETAX_DOCTY,
        TAXINV     TYPE  ZSDSDE_ETAX_TAXINVID,
*       Billing Doc Fields
        VBELN      TYPE  VBRK-VBELN,
        BELNR      TYPE  VBRK-BELNR,
        FKDAT      TYPE  VBRK-FKDAT,
        FKART      TYPE  VBRK-FKART,
        FKART_TXT  TYPE  TVFKT-VTEXT,
        BUPLA      TYPE  VBRK-BUPLA,
        KUNNR      TYPE  VBRK-KUNRG,
        XBLNR      TYPE  VBRK-XBLNR,
        ZTERM      TYPE  VBRK-ZTERM,
        ZTERM_TXT  TYPE  TVZBT-VTEXT,
        INCO1      TYPE  VBRK-INCO1,
        ERNAM      TYPE  VBRK-ERNAM,
        ERDAT      TYPE  VBRK-ERDAT,
        WAERS      TYPE  VBRK-WAERK,
        BSTKD      TYPE  VBKD-BSTKD,
        BSTDK      TYPE  VBKD-BSTDK,
        AUGRU      TYPE  VBRP-AUGRU_AUFT,
        FORM_FNAME TYPE  STRING,
        CANCEL     TYPE  FLAG,
        DUEDT      TYPE  SY-DATUM,
*       CN/DN Fields
        REF_TAXINV TYPE  ZSDSDE_ETAX_TAXINVID,
        REF_DOCTY  TYPE  ZSDSDE_ETAX_DOCTY,
        REF_ERDAT  TYPE  VBRK-ERDAT,
*       ETax Map Field
        DESCP_TH   TYPE  ZSDSDE_ETAX_DESCP_TH,
        DCGRP      TYPE  ZSDSDE_ETAX_DCGRP,
        CAUSE_CD   TYPE  ZSDSDE_ETAX_CAUSE_CD,
        CAUSE_TX   TYPE  ZSDSDE_ETAX_CAUSE_TX,
        TAXTY      TYPE  ZSDSDE_ETAX_TAXTY,
        TAXRATE    TYPE  P LENGTH 4 DECIMALS 2,
*       Customer Data
        KUNNR_NAME TYPE  TEXT200,
        STCD3      TYPE  KNA1-STCD3,
        BRANCH     TYPE  FITHA_PBUPL_D-J_1TPBUPL,
        BRANCH_TX  TYPE  FITHA_PBUPL_D_T-DESCRIPTION,
        EMAIL      TYPE  ADR6-SMTP_ADDR,
        CUST_ADRC  TYPE  TS_CUSTOMER-ADRC,
        CUST_ETAX  TYPE  TS_CUSTOMER_ETAX,
*       Processing Fields
        REPLC      TYPE  FLAG,
        SAP_MODULE TYPE  ZSDSDE_ETAX_MODULE,
        MSGTY      TYPE  SY-MSGTY,
        MSGTX      TYPE  TEXT1000,
*       Amount Fields
        GROSS_AMT  TYPE  NETWR,
        DISC_AMT   TYPE  NETWR,
        CHRG_AMT   TYPE  NETWR,
        VATBS_AMT  TYPE  NETWR,
        NET1_AMT   TYPE  NETWR,
        VAT_AMT    TYPE  NETWR,
        NET2_AMT   TYPE  NETWR,
        ORG_AMT    TYPE  NETWR,
        CORRCT_AMT TYPE  NETWR,
        DIFF_AMT   TYPE  NETWR,
        ALLW_AMT   TYPE  NETWR,
*       Charge detail
        CHRG_TAB   TYPE  TT_CHRG_AMT,
*       Item Data
        ITEM       TYPE  TT_ETAX_ITEM,
      END OF TS_ETAX_DATA .
    TYPES:
      TT_ETAX_DATA  TYPE  STANDARD TABLE OF TS_ETAX_DATA
                                              WITH DEFAULT KEY .
    TYPES:
      BEGIN OF TS_ETAX_CANC,
*       Key Fields
        BUKRS    TYPE  VBRK-BUKRS,
        GJAHR    TYPE  VBRK-GJAHR,
        DOCTY    TYPE  ZSDSDE_ETAX_DOCTY,
        TAXINV   TYPE  ZSDSDE_ETAX_TAXINVID,
*       Data Fields
        VBELN    TYPE  VBRK-VBELN,
        BELNR    TYPE  VBRK-BELNR,
        BUPLA    TYPE  VBRK-BUPLA,
        CAUSE_CD TYPE  ZSDSDE_ETAX_CAUSE_CD,
        CAUSE_TX TYPE  ZSDSDE_ETAX_CAUSE_TX,
      END OF TS_ETAX_CANC .
    TYPES:
      BEGIN OF TS_CONFIG,
        ETXID    TYPE ZSDSSDC011-ETXID,
        URI_AUTH TYPE ZSDSSDC011-URI_AUTH,
        URI_SIGN TYPE ZSDSSDC011-URI_SIGN,
        URI_CANC TYPE ZSDSSDC011-URI_CANC,
        USERNM   TYPE ZSDSSDC011-USERNM,
        PASSWD   TYPE ZSDSSDC011-PASSWD,
        CLIENTID TYPE ZSDSSDC011-CLIENTID,
      END OF TS_CONFIG .
    TYPES:
      BEGIN OF TS_LOG,
        BUKRS         TYPE  ZSDSSDT021-BUKRS,
        GJAHR         TYPE  ZSDSSDT021-GJAHR,
        DOCTY         TYPE  ZSDSSDT021-DOCTY,
        TAXINV        TYPE  ZSDSSDT021-TAXINV,
        SEQNO         TYPE  ZSDSSDT021-SEQNO,
        VBELN         TYPE  ZSDSSDT021-VBELN,
        BELNR         TYPE  ZSDSSDT021-BELNR,
        CANCEL        TYPE  ZSDSSDT021-CANCEL,
        USNAM         TYPE  ZSDSSDT021-USNAM,
        STDAT         TYPE  ZSDSSDT021-STDAT,
        STTIM         TYPE  ZSDSSDT021-STTIM,
        ENDAT         TYPE  ZSDSSDT021-ENDAT,
        ENTIM         TYPE  ZSDSSDT021-ENTIM,
        REQUEST_JSON  TYPE  ZSDSSDT021-REQUEST_JSON,
        RESPONSE_JSON TYPE  ZSDSSDT021-RESPONSE_JSON,
        HTTP_CODE     TYPE  ZSDSSDT021-HTTP_CODE,
        HTTP_REASON   TYPE  ZSDSSDT021-HTTP_REASON,
        HTML_ERROR    TYPE  ZSDSSDT021-HTML_ERROR,
        STATUS        TYPE  ZSDSSDT021-STATUS,
        MESSAGE       TYPE  ZSDSSDT021-MESSAGE,
      END OF TS_LOG .
    TYPES:
      BEGIN OF TS_REFINFO,
        BUKRS       TYPE  BKPF-BUKRS,
        BELNR       TYPE  BKPF-BELNR,
        GJAHR       TYPE  BKPF-GJAHR,
        XBLNR       TYPE  BKPF-XBLNR,
        BLART       TYPE  BKPF-BLART,
        BUDAT       TYPE  BKPF-BUDAT,
        ERNAM       TYPE  BKPF-USNAM,
        ERDAT       TYPE  BKPF-CPUDT,
        ERTIM       TYPE  BKPF-CPUTM,
        WAERS       TYPE  BKPF-WAERS,
        ORG_AMT     TYPE  BSEG-WRBTR,
        MWSKZ       TYPE  BSEG-MWSKZ,
        J_1TPBUPL   TYPE  BSEG-J_1TPBUPL,
        DESCRIPTION TYPE  FITHA_PBUPL_D_T-DESCRIPTION,
        DOCTY       TYPE  ZSDSSDC026-DOCTY,
        CORRCT_AMT  TYPE  BSEG-WRBTR,
        DIFF_AMT    TYPE  BSEG-WRBTR,
        SPECIAL_REF TYPE  FLAG,
        ITEM_TEXT   TYPE  STRING,
      END OF TS_REFINFO .
    TYPES:
      BEGIN OF TS_REFINPUT,
        BUKRS  TYPE  BSEG-BUKRS,
        BELNR  TYPE  BSEG-BELNR,
        GJAHR  TYPE  BSEG-GJAHR,
        BUZEI  TYPE  BSEG-BUZEI,
        SGTXT  TYPE  BSEG-SGTXT,
        UMSKZ  TYPE  BSEG-UMSKZ,
        ZUONR  TYPE  BSEG-ZUONR,
        KUNNR  TYPE  BSEG-KUNNR,
        REBZG  TYPE  BSEG-REBZG,
        REBZJ  TYPE  BSEG-REBZJ,
        REBZZ  TYPE  BSEG-REBZZ,
        ERDAT  TYPE  BKPF-CPUDT,
        ERTIM  TYPE  BKPF-CPUTM,
        SHKZG  TYPE  BSEG-SHKZG,
        AMOUNT TYPE  BSEG-WRBTR,
      END OF TS_REFINPUT .
    TYPES:
      BEGIN OF TS_ORIGINAL_INFO,
        VBELN TYPE  VBRP-VBELN,
        POSNR TYPE  VBRP-POSNR,
        KZWI3 TYPE  VBRP-KZWI3,
        XBLNR TYPE  VBRK-XBLNR,
        FKDAT TYPE  VBRK-FKDAT,
        DOCTY TYPE  ZSDSSDC017-DOCTY,
      END OF TS_ORIGINAL_INFO .

    CONSTANTS GC_API_SIGN TYPE CHAR1 VALUE '1' ##NO_TEXT.
    CONSTANTS GC_API_CANC TYPE CHAR1 VALUE '2' ##NO_TEXT.
    CONSTANTS GC_POST TYPE CHAR1 VALUE '2' ##NO_TEXT.
    CONSTANTS GC_GET TYPE CHAR1 VALUE '1' ##NO_TEXT.
    CONSTANTS GC_JSON TYPE CHAR1 VALUE '1' ##NO_TEXT.
    CONSTANTS GC_HTML TYPE CHAR1 VALUE '2' ##NO_TEXT.
    CONSTANTS GC_MODULE_SD TYPE TS_ETAX_DATA-SAP_MODULE VALUE 'SD' ##NO_TEXT.
    CONSTANTS GC_MODULE_FI TYPE TS_ETAX_DATA-SAP_MODULE VALUE 'FI' ##NO_TEXT.
    CONSTANTS GC_CN TYPE VBRK-VBTYP VALUE 'O' ##NO_TEXT.
    CONSTANTS GC_INV TYPE VBRK-VBTYP VALUE 'M' ##NO_TEXT.
    CONSTANTS GC_DN TYPE VBRK-VBTYP VALUE 'P' ##NO_TEXT.
    CONSTANTS GC_CANC TYPE VBRK-VBTYP VALUE 'N' ##NO_TEXT.
    CONSTANTS GC_MEMID TYPE CHAR20 VALUE 'ZZ_ETAX_KEY' ##NO_TEXT.
    CLASS-DATA GF_TRN_SIGN_REQ TYPE ZSDSDE_TRANSFORM VALUE 'ZSDSSD_REST_ETAX_SIGN_REQ' ##NO_TEXT.
    CLASS-DATA GF_TRN_SIGN_RESP TYPE ZSDSDE_TRANSFORM VALUE 'ZSDSSD_REST_ETAX_SIGN_RESP' ##NO_TEXT.

    CLASS-METHODS GET_NEW_REF_INFO_START
      RETURNING
        VALUE(RF_DATUM) TYPE SY-DATUM .
    CLASS-METHODS GET_REF_INFO
      IMPORTING
        !IS_INPUT    TYPE TS_REFINPUT
        !IF_READITEM TYPE XFLAG DEFAULT ' '
      EXPORTING
        !ES_REFINFO  TYPE TS_REFINFO .
    CLASS-METHODS CALL_SIGN_SERVICE
      IMPORTING
        !IS_ETAX_DATA TYPE TS_ETAX_DATA
      EXPORTING
        !ES_RESPONSE  TYPE ZSDSSDS095
        !ES_RETURN    TYPE BAPIRET2 .
    CLASS-METHODS CALL_CANCEL_SERVICE
      IMPORTING
        !IS_ETAX_CANC TYPE TS_ETAX_CANC
      EXPORTING
        !ES_RESPONSE  TYPE ZSDSSDS095
        !ES_RETURN    TYPE BAPIRET2 .
    CLASS-METHODS CONVERT_PDF_TO_BASE64
      IMPORTING
        !IF_FNAME  TYPE STRING
      EXPORTING
        !EF_BASE64 TYPE STRING
      EXCEPTIONS
        READ_FILE_ERROR
        CONVERT_ERROR .
    CLASS-METHODS CONVERT_BASE64_TO_BINARY
      IMPORTING
        !IF_BASE64     TYPE STRING
      EXPORTING
        !ET_BINARY     TYPE SOLIX_TAB
        !EF_XSTRING    TYPE XSTRING
        !EF_OUTPUT_LEN TYPE I .
    CLASS-METHODS GET_DATA_SD
      IMPORTING
        !IF_BUKRS    TYPE BKPF-BUKRS
        !IF_GJAHR    TYPE BKPF-GJAHR
        !IT_COND     TYPE /IWBEP/T_MGW_SELECT_OPTION
        !IF_NEW      TYPE XFLAG DEFAULT SPACE
        !IF_NEW_FILE TYPE XFLAG DEFAULT SPACE
      EXPORTING
        !ET_DATA     TYPE TT_ETAX_DATA .
    CLASS-METHODS GET_DATA_FI
      IMPORTING
        !IF_BUKRS    TYPE BKPF-BUKRS
        !IF_GJAHR    TYPE BKPF-GJAHR
        !IT_COND     TYPE /IWBEP/T_MGW_SELECT_OPTION
        !IF_NEW      TYPE XFLAG DEFAULT SPACE
        !IF_NEW_FILE TYPE XFLAG DEFAULT SPACE
      EXPORTING
        !ET_DATA     TYPE TT_ETAX_DATA .
    CLASS-METHODS GET_COMPANY_INFO
      IMPORTING
        !IF_BUKRS         TYPE T001-BUKRS
        !IF_BRANCH        TYPE J_1BBRANCH-BRANCH
      RETURNING
        VALUE(RS_COMPANY) TYPE TS_COMPANY .
    CLASS-METHODS GET_CUSTOMER_INFO
      IMPORTING
        !IF_KUNNR          TYPE KNA1-KUNNR
        !IF_J_1TPBUPL      TYPE BSEG-J_1TPBUPL OPTIONAL
        !IF_VBELN          TYPE VBRK-VBELN OPTIONAL
        !IS_BSEC           TYPE BSEC OPTIONAL
        !IF_NATION         TYPE ADRC-NATION DEFAULT ' '
      RETURNING
        VALUE(RS_CUSTOMER) TYPE TS_CUSTOMER .
    CLASS-METHODS TRANSFORM_JSON_TO_DATA
      IMPORTING
        !IF_JSON      TYPE ZSDSDE_JSON
        !IF_TRANSFORM TYPE ZSDSDE_TRANSFORM
      EXPORTING
        !ES_DATA      TYPE ANY
      EXCEPTIONS
        TRANSFORM_ERROR .
protected section.
PRIVATE SECTION.

  CLASS-DATA GF_ETXID TYPE ZSDSDE_ETXID VALUE 'MAIN' ##NO_TEXT.
  CLASS-DATA GF_POPUP TYPE FLAG VALUE ' ' ##NO_TEXT.
  CLASS-DATA GS_EXCH_CONTEXT TYPE TS_EXCH_CONTEXT .
  CLASS-DATA GR_KSCHL_CHARGE TYPE TT_KSCHL_RANGE .
  CLASS-DATA GR_KSCHL_DISCOUNT TYPE TT_KSCHL_RANGE .
  CLASS-DATA GT_INTF_FORM TYPE TT_INTF_FORM .
  CLASS-DATA GF_TRN_CANC_REQ TYPE ZSDSDE_TRANSFORM VALUE 'ZSDSSD_REST_ETAX_CANC_REQ' ##NO_TEXT.
  CLASS-DATA GF_TRN_CANC_RESP TYPE ZSDSDE_TRANSFORM VALUE 'ZSDSSD_REST_ETAX_SIGN_RESP' ##NO_TEXT.
  CLASS-DATA GR_NOSHOW_MATNR TYPE TT_MATNR_RANGE .
  CLASS-DATA GR_KALSM_SUBTOT4 TYPE TT_KALSM_RANGE .
  CLASS-DATA GT_DEFT_BUPLA TYPE TT_DEFT_BUPLA .
  CLASS-DATA GR_FI_UMSKZ TYPE TT_UMSKZ_RANGE .
  CLASS-DATA GF_NEW_REF_START TYPE SY-DATUM .
  CLASS-DATA GR_BLART_CN TYPE TT_BLART_RANGE .
  CLASS-DATA GR_SPECIAL_ZUONR TYPE TT_ZUONR_RANGE .

  CLASS-METHODS CONVERT_REF_DATE_SD
    IMPORTING
      !IF_INPUT TYPE CLIKE
    EXPORTING
      !EF_DATUM TYPE SY-DATUM .
  CLASS-METHODS GET_REF_INFO_SD
    IMPORTING
      !IF_VBELN TYPE VBRK-VBELN
      !IF_AUBEL TYPE VBRP-AUBEL
      !IF_AUPOS TYPE VBRP-AUPOS
    EXPORTING
      !ES_ORG   TYPE TS_ORIGINAL_INFO .
  CLASS-METHODS GET_FORM_LANG
    IMPORTING
      !IS_FORMFILE     TYPE TS_FORMFILE
      !IF_VBELN        TYPE VBRK-VBELN OPTIONAL
    RETURNING
      VALUE(RF_NATION) TYPE ADRC-NATION .
  CLASS-METHODS ASSIGN_ETAX_CANCEL
    IMPORTING
      !IS_DATA      TYPE TS_ETAX_CANC
    EXPORTING
      !ES_ETAX_CANC TYPE ZSDSSDS109 .
  CLASS-METHODS ASSIGN_ITEM_DESCP
    IMPORTING
      !IS_BILL  TYPE TS_BILL
      !IS_ITEM  TYPE TS_BILL_ITEM
      !IT_ITEM  TYPE TT_BILL_ITEM
    EXPORTING
      !EF_DESCP TYPE TS_ETAX_ITEM-DESCP .
  CLASS-METHODS VALIDATE_ETAX_DATA
    IMPORTING
      !IS_DATA     TYPE TS_ETAX_DATA
      !IF_AEDAT    TYPE SY-DATUM
      !IS_FORMFILE TYPE TS_FORMFILE
      !IS_LOG      TYPE TS_ETAX_LOG
    EXPORTING
      !EF_MSGTY    TYPE TS_ETAX_DATA-MSGTY
      !EF_MSGTX    TYPE TS_ETAX_DATA-MSGTX .
  CLASS-METHODS GET_FORM_FILE_LIST
    IMPORTING
      !IF_MODULE   TYPE TS_INTF_FORM-SAP_MODULE
      !IF_BUKRS    TYPE BKPF-BUKRS
      !IF_GJAHR    TYPE BKPF-GJAHR
      !IT_DATUM    TYPE TT_DATUM_RANGE
    EXPORTING
      !ET_FORMFILE TYPE TT_FORMFILE
      !ET_XBLNR    TYPE TT_XBLNR_RANGE .
  CLASS-METHODS LOCK_PROCESSING
    IMPORTING
      !IF_BUKRS  TYPE ZSDSSDT021-BUKRS
      !IF_GJAHR  TYPE ZSDSSDT021-GJAHR
      !IF_DOCTY  TYPE ZSDSSDT021-DOCTY
      !IF_TAXINV TYPE ZSDSSDT021-TAXINV
    EXPORTING
      !ES_RETURN TYPE BAPIRET2 .
  CLASS-METHODS SAVE_PROCESSING_LOG
    IMPORTING
      !IS_LOG TYPE TS_LOG
    EXCEPTIONS
      LOG_ERROR .
  CLASS-METHODS UNLOCK_PROCESSING
    IMPORTING
      !IF_BUKRS  TYPE ZSDSSDT021-BUKRS
      !IF_GJAHR  TYPE ZSDSSDT021-GJAHR
      !IF_DOCTY  TYPE ZSDSSDT021-DOCTY
      !IF_TAXINV TYPE ZSDSSDT021-TAXINV .
  CLASS-METHODS ASSIGN_ETAX_SIGN
    IMPORTING
      !IS_ETAX_DATA TYPE TS_ETAX_DATA
    EXPORTING
      !ES_ETAX_SIGN TYPE ZSDSSDS061 .
  CLASS-METHODS ASSIGN_ETAX_AMOUNT
    IMPORTING
      !IF_AMT      TYPE TS_ETAX_DATA-ORG_AMT
      !IF_CURRENCY TYPE TS_ETAX_DATA-WAERS
    EXPORTING
      !ET_AMOUNT   TYPE ZSDSSDS083_TT .
  CLASS-METHODS ASSIGN_ETAX_ITEM
    IMPORTING
      !IS_DATA     TYPE TS_ETAX_ITEM
    EXPORTING
      !ES_LINEITEM TYPE ZSDSSDS084 .
  CLASS-METHODS ASSIGN_ETAX_TAX
    IMPORTING
      !IF_VATBS_AMT TYPE TS_ETAX_DATA-VATBS_AMT
      !IF_VAT_AMT   TYPE TS_ETAX_DATA-VAT_AMT
      !IF_WAERS     TYPE TS_ETAX_DATA-WAERS
      !IF_TAXTY     TYPE TS_ETAX_DATA-TAXTY
      !IF_TAXRATE   TYPE TS_ETAX_DATA-TAXRATE
    CHANGING
      !CT_TRADE_TAX TYPE ZSDSSDS079_TT .
  CLASS-METHODS ASSIGN_TRADEPARTY
    IMPORTING
      !IF_ID         TYPE CLIKE
      !IF_TAXID      TYPE CLIKE
      !IF_BRANCH     TYPE CLIKE
      !IF_BRANCH_TX  TYPE CLIKE OPTIONAL
      !IS_ADRC       TYPE ADRC
      !IS_RD_ADDR    TYPE TS_RD_ADDR OPTIONAL
    EXPORTING
      !ES_TRADEPARTY TYPE ZSDSSDS069 .
  CLASS-METHODS GET_CNTY_SCHEME
    IMPORTING
      !IF_LAND1     TYPE LLAND
    EXPORTING
      !EF_SCHEMA_ID TYPE ZSDSDE_ETAX_SCHEMA .
  CLASS-METHODS GET_TAX_RATE
    IMPORTING
      !IF_MWSKZ TYPE MWSKZ
    EXPORTING
      !EF_RATE  TYPE TS_ETAX_DATA-TAXRATE .
  CLASS-METHODS GET_CAUSE_MAP
    IMPORTING
      !IF_AUGRU    TYPE AUGRU
      !IF_DOCTY    TYPE ZSDSDE_ETAX_DOCTY
    EXPORTING
      !EF_CAUSE_CD TYPE ZSDSDE_ETAX_CAUSE_CD
      !EF_CAUSE_TX TYPE ZSDSDE_ETAX_CAUSE_TX .
  CLASS-METHODS SHOW_POPUP
    IMPORTING
      !IS_DATA    TYPE ANY
      !IF_TYPE    TYPE CHAR1
      !IF_SECTION TYPE CLIKE .
  CLASS-METHODS CONSUME_REST_API
    IMPORTING
      !IF_TYPE          TYPE CHAR1 OPTIONAL
      !IS_CONF          TYPE TS_CONFIG
      !IF_REQUEST_JSON  TYPE ZSDSDE_JSON
    EXPORTING
      !EF_RESPONSE_JSON TYPE ZSDSDE_JSON
      !EF_HTTP_CODE     TYPE TS_LOG-HTTP_CODE
      !EF_HTTP_REASON   TYPE TS_LOG-HTTP_REASON
      !EF_HTML_ERROR    TYPE TS_LOG-HTML_ERROR
    EXCEPTIONS
      URL_ERROR
      SEND_ERROR .
  CLASS-METHODS GET_CONFIG
    IMPORTING
      !IF_ETXID      TYPE ZSDSDE_ETXID
    RETURNING
      VALUE(RS_CONF) TYPE TS_CONFIG .
  CLASS-METHODS TRANSFORM_DATA_TO_JSON
    IMPORTING
      !IF_TRANSFORM TYPE ZSDSDE_TRANSFORM
      !IS_DATA      TYPE ANY
    EXPORTING
      !EF_JSON      TYPE ZSDSDE_JSON
    EXCEPTIONS
      TRANSFORM_ERROR .
  CLASS-METHODS GET_CONSTANTS .
ENDCLASS.



CLASS ZCL_SDSSD_ETAX_INTERFACE IMPLEMENTATION.


METHOD ASSIGN_ETAX_AMOUNT.

  DATA:
    LT_AMOUNT  TYPE  ZSDSSDS083_TT.

  DATA:
    LF_TEXT35  TYPE  TEXT35.


* Initialize Output
  CLEAR: ET_AMOUNT.

  CLEAR LT_AMOUNT.
  WRITE IF_AMT TO LF_TEXT35 LEFT-JUSTIFIED NO-GROUPING
                            CURRENCY IF_CURRENCY.
  CONDENSE LF_TEXT35 NO-GAPS.
  INSERT VALUE #( CURRENCYID = IF_CURRENCY
                  VALUE      = LF_TEXT35
                 ) INTO TABLE LT_AMOUNT.

* Assign Output
  ET_AMOUNT = LT_AMOUNT.

ENDMETHOD.


METHOD ASSIGN_ETAX_CANCEL.

* Initialize Output
  CLEAR ES_ETAX_CANC.

  ES_ETAX_CANC-DOCUMENT_NUMBER  = IS_DATA-TAXINV.
  ES_ETAX_CANC-FISCALYEAR       = IS_DATA-GJAHR.
  ES_ETAX_CANC-COMPANYCODE      = IS_DATA-BUKRS.
  ES_ETAX_CANC-DOCUMENTTYPE     = IS_DATA-DOCTY.
  ES_ETAX_CANC-BRANCH           = |0{ IS_DATA-BUPLA }|.
*  ES_ETAX_CANC-INTERNALDOCNO
*  ES_ETAX_CANC-TRANSCODE
  ES_ETAX_CANC-PURPOSECODE      = IS_DATA-CAUSE_CD.

ENDMETHOD.


METHOD ASSIGN_ETAX_ITEM.

  DATA:
    LT_AMOUNT1 TYPE ZSDSSDS063_TT.

  DATA:
    LF_TEXT35  TYPE  TEXT35,
    LF_TEXT256 TYPE  TEXT256,
    LF_AMT     TYPE  TS_ETAX_ITEM-GROSS_AMT.


* Initialize Output
  CLEAR ES_LINEITEM.

* ---------
* DOCUMENT
* ---------
  WRITE IS_DATA-ID TO ES_LINEITEM-DOCUMENT-LINEID LEFT-JUSTIFIED NO-GROUPING.
  CONDENSE ES_LINEITEM-DOCUMENT-LINEID NO-GAPS.

* ---------
* TRADE_PRODUCT
* ---------
  ES_LINEITEM-TRADE_PRODUCT-ID = IS_DATA-MATNR.

  LF_TEXT256 = IS_DATA-DESCP.
  INSERT LF_TEXT256 INTO TABLE ES_LINEITEM-TRADE_PRODUCT-NAME.

* ---------
* PRODUCT_TRADEPRICE-CHARGE_AMOUNT
* ---------
* Calc Price Per Unit
  LF_AMT = IS_DATA-GROSS_AMT / IS_DATA-FKIMG.

  ASSIGN_ETAX_AMOUNT(
    EXPORTING
      IF_AMT      = LF_AMT
      IF_CURRENCY = IS_DATA-WAERS
    IMPORTING
      ET_AMOUNT   = ES_LINEITEM-TRADE_AGREEMENT-PRODUCT_TRADEPRICE-CHARGE_AMOUNT ).

* ---------
* TRADE_DELIVERY
* ---------
  WRITE IS_DATA-VRKME TO ES_LINEITEM-TRADE_DELIVERY-BILLED_QUANTITY-UNITCODE.
  WRITE IS_DATA-FKIMG TO ES_LINEITEM-TRADE_DELIVERY-BILLED_QUANTITY-VALUE
                         UNIT IS_DATA-VRKME LEFT-JUSTIFIED NO-GROUPING.
  CONDENSE ES_LINEITEM-TRADE_DELIVERY-BILLED_QUANTITY-VALUE NO-GAPS.

* ---------
* TRADE_TAX
* ---------
  ASSIGN_ETAX_TAX(
    EXPORTING
      IF_VATBS_AMT = IS_DATA-VATBS_AMT
      IF_VAT_AMT   = IS_DATA-VAT_AMT
      IF_WAERS     = IS_DATA-WAERS
      IF_TAXTY     = IS_DATA-TAXTY
      IF_TAXRATE   = IS_DATA-TAXRATE
    CHANGING
      CT_TRADE_TAX = ES_LINEITEM-TRADE_SETTLEMENT-TRADE_TAX ).

* ---------
* TRADE_ALLOWANCE_CHARGE
* ---------
  LOOP AT IS_DATA-CHRG_TAB ASSIGNING FIELD-SYMBOL(<L_CHRG_TAB>)
                           WHERE CHRG_AMT IS NOT INITIAL.
    CLEAR LT_AMOUNT1.

*   Assign Amount
    LF_AMT = <L_CHRG_TAB>-CHRG_AMT.

    WRITE LF_AMT TO LF_TEXT35 LEFT-JUSTIFIED NO-GROUPING
                                             CURRENCY IS_DATA-WAERS.
    CONDENSE LF_TEXT35 NO-GAPS.
    INSERT LF_TEXT35 INTO TABLE LT_AMOUNT1.
    INSERT VALUE #( CHARGEINDICATOR   = <L_CHRG_TAB>-CHRG_IND
                    ACTUALAMOUNT      = LT_AMOUNT1
                    REASONCODE        = <L_CHRG_TAB>-DISC_CD
                    REASON            = <L_CHRG_TAB>-DESCP_TH )
           INTO TABLE ES_LINEITEM-TRADE_SETTLEMENT-TRADE_ALLOWANCE_CHARGE.
  ENDLOOP.

* ---------
* TRADE_SETTLEMENT_LINE-TAXTOTAL_AMOUNT
* ---------
  ASSIGN_ETAX_AMOUNT(
    EXPORTING
      IF_AMT      = IS_DATA-VAT_AMT
      IF_CURRENCY = IS_DATA-WAERS
    IMPORTING
      ET_AMOUNT   = ES_LINEITEM-TRADE_SETTLEMENT-TRADE_SETTLEMENT_LINE-TAXTOTAL_AMOUNT ).

* ---------
* TRADE_SETTLEMENT_LINE-TOTAL_AMOUNT
* ---------
  ASSIGN_ETAX_AMOUNT(
    EXPORTING
      IF_AMT      = IS_DATA-NET1_AMT
      IF_CURRENCY = IS_DATA-WAERS
    IMPORTING
      ET_AMOUNT   = ES_LINEITEM-TRADE_SETTLEMENT-TRADE_SETTLEMENT_LINE-TOTAL_AMOUNT ).

* ---------
* TRADE_SETTLEMENT_LINE-GRANDTOTAL_AMOUNT
* ---------
  ASSIGN_ETAX_AMOUNT(
    EXPORTING
      IF_AMT      = IS_DATA-NET2_AMT
      IF_CURRENCY = IS_DATA-WAERS
    IMPORTING
      ET_AMOUNT   = ES_LINEITEM-TRADE_SETTLEMENT-TRADE_SETTLEMENT_LINE-GRANDTOTAL_AMOUNT ).

ENDMETHOD.


METHOD ASSIGN_ETAX_SIGN.

  DATA:
    LT_AMOUNT1 TYPE ZSDSSDS063_TT,
    LT_DESC    TYPE ZSDSSDS0860_TT.

  DATA:
    LS_LINEITEM TYPE  ZSDSSDS084.

  DATA:
    LF_TEXT35   TYPE  TEXT35,
    LF_TEXT256  TYPE  TEXT256,
    LF_DATETIME TYPE  ZSDSDE_REST_DATUM,
    LF_DATUM    TYPE  SY-DATUM.


* Initialize Output
  CLEAR ES_ETAX_SIGN.

* Get Constants
  GET_CONSTANTS( ).

* Get Company Data
  DATA(LS_COMPANY) = GET_COMPANY_INFO( IF_BUKRS  = IS_ETAX_DATA-BUKRS
                                       IF_BRANCH = IS_ETAX_DATA-BUPLA ).

* ---------------------
* Root Fields
* ---------------------
* Replace Flag
  CASE IS_ETAX_DATA-REPLC.
    WHEN 'X'.
      ES_ETAX_SIGN-REPLACE_FLAG = 'Y'.
    WHEN SPACE.
      ES_ETAX_SIGN-REPLACE_FLAG = 'N'.
    WHEN OTHERS.
      ES_ETAX_SIGN-REPLACE_FLAG = 'N'.
  ENDCASE.

  ES_ETAX_SIGN-BRANCH = |0{ IS_ETAX_DATA-BUPLA }|.
  ES_ETAX_SIGN-REQ_SEND_SMS   = IS_ETAX_DATA-CUST_ETAX-REQ_SEND_SMS.
  ES_ETAX_SIGN-MOBILE_NUMBER  = IS_ETAX_DATA-CUST_ETAX-MOBILE_NUMBER.
  ES_ETAX_SIGN-REQ_SEND_MAIL  = IS_ETAX_DATA-CUST_ETAX-REQ_SEND_MAIL.
  ES_ETAX_SIGN-EMAIL          = IS_ETAX_DATA-CUST_ETAX-EMAIL.
*  ES_ETAX_SIGN-PDF_PASSWORD
*  ES_ETAX_SIGN-INTERNALDOCNO
*  ES_ETAX_SIGN-TRANSCODE
*  ES_ETAX_SIGN-FLAG_DOCU_PRINT
*  ES_ETAX_SIGN-PRINT_USER
*  ES_ETAX_SIGN-RDFLAG
*  ES_ETAX_SIGN-FORMNAME

  IF IS_ETAX_DATA-FORM_FNAME IS NOT INITIAL.
    CONVERT_PDF_TO_BASE64(
      EXPORTING
        IF_FNAME  = IS_ETAX_DATA-FORM_FNAME
      IMPORTING
        EF_BASE64 = ES_ETAX_SIGN-DOCUMENT ).
  ENDIF.

* ---------------------
* EXCH_DOCU_CONTEXT
* ---------------------
  INSERT VALUE #( ID-SCHEME_AGENCY_ID  = GS_EXCH_CONTEXT-SCHEME_AGENCY_ID
                  ID-SCHEME_VERSION_ID = GS_EXCH_CONTEXT-SCHEME_VERSION_ID
                  ID-VALUE             = GS_EXCH_CONTEXT-VALUE )
         INTO TABLE ES_ETAX_SIGN-EXCH_DOCU_CONTEXT-CONTEXT_PARAMS.

* ---------------------
* EXCH_DOCUMENT
* ---------------------
  ES_ETAX_SIGN-EXCH_DOCUMENT-ID = IS_ETAX_DATA-TAXINV.
  LF_TEXT35 = IS_ETAX_DATA-DESCP_TH.
  INSERT LF_TEXT35 INTO TABLE ES_ETAX_SIGN-EXCH_DOCUMENT-NAME.
  ES_ETAX_SIGN-EXCH_DOCUMENT-TYPE_CODE = IS_ETAX_DATA-DOCTY.
  ZCL_SDSCA_REST_INTF_UTILITY=>CONVERT_DATE_TIME_TO_ISO(
    EXPORTING
      IF_DATUM  = IS_ETAX_DATA-FKDAT
      IF_UZEIT  = '000000'
    IMPORTING
      EF_OUTPUT = ES_ETAX_SIGN-EXCH_DOCUMENT-ISSUE_DATETIME ).
  ES_ETAX_SIGN-EXCH_DOCUMENT-PURPOSE      = IS_ETAX_DATA-CAUSE_TX.
  ES_ETAX_SIGN-EXCH_DOCUMENT-PURPOSE_CODE = IS_ETAX_DATA-CAUSE_CD.
*  ES_ETAX_SIGN-EXCH_DOCUMENT-GLOBAL_ID

* For INV Type Group, Create date must not send
  IF IS_ETAX_DATA-DCGRP NE 'INV'.
    ZCL_SDSCA_REST_INTF_UTILITY=>CONVERT_DATE_TIME_TO_ISO(
      EXPORTING
        IF_DATUM  = IS_ETAX_DATA-ERDAT
        IF_UZEIT  = '000000'
      IMPORTING
        EF_OUTPUT = LF_DATETIME ).
    INSERT LF_DATETIME INTO TABLE ES_ETAX_SIGN-EXCH_DOCUMENT-CREATION_DATETIME.
  ENDIF.

* ---------------------
* TRADE_TRANSACTION - TRADE_AGREEMENT
* ---------------------
* Seller
  ASSIGN_TRADEPARTY(
    EXPORTING
      IF_ID         = LS_COMPANY-BUKRS
      IF_TAXID      = LS_COMPANY-STCEG+2
      IF_BRANCH     = |0{ IS_ETAX_DATA-BUPLA }|
      IS_ADRC       = LS_COMPANY-ADRC
      IS_RD_ADDR    = LS_COMPANY-ADDIT
    IMPORTING
      ES_TRADEPARTY = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_AGREEMENT-SELLER_TRADEPARTY ).

* Buyer
  ASSIGN_TRADEPARTY(
    EXPORTING
      IF_ID         = IS_ETAX_DATA-KUNNR
      IF_TAXID      = IS_ETAX_DATA-STCD3
      IF_BRANCH     = IS_ETAX_DATA-BRANCH
      IF_BRANCH_TX  = IS_ETAX_DATA-BRANCH_TX
      IS_ADRC       = IS_ETAX_DATA-CUST_ADRC
    IMPORTING
      ES_TRADEPARTY = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_AGREEMENT-BUYER_TRADEPARTY ).

* Buyer Reference
  ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_AGREEMENT-BUYER_ORDERREF_DOCUMENT-ISSUERASSIGNEDID = IS_ETAX_DATA-BSTKD.
  IF IS_ETAX_DATA-BSTDK IS NOT INITIAL.
    ZCL_SDSCA_REST_INTF_UTILITY=>CONVERT_DATE_TIME_TO_ISO(
      EXPORTING
        IF_DATUM  = IS_ETAX_DATA-BSTDK
        IF_UZEIT  = '000000'
      IMPORTING
        EF_OUTPUT = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_AGREEMENT-BUYER_ORDERREF_DOCUMENT-ISSUEDATETIME ).
  ENDIF.

* Additional Reference (CN & Cancel Scenario)
  IF IS_ETAX_DATA-REF_TAXINV IS NOT INITIAL.
    ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_AGREEMENT-ADDITIONAL_REF_DOCUMENT-ISSUERASSIGNEDID = IS_ETAX_DATA-REF_TAXINV.
    ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_AGREEMENT-ADDITIONAL_REF_DOCUMENT-REFERENCETYPECODE = IS_ETAX_DATA-REF_DOCTY.
    ZCL_SDSCA_REST_INTF_UTILITY=>CONVERT_DATE_TIME_TO_ISO(
      EXPORTING
        IF_DATUM  = IS_ETAX_DATA-REF_ERDAT
        IF_UZEIT  = '000000'
      IMPORTING
        EF_OUTPUT = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_AGREEMENT-ADDITIONAL_REF_DOCUMENT-ISSUEDATETIME ).
  ENDIF.

* ---------------------
* TRADE_TRANSACTION - TRADE_DELIVERY
* ---------------------

* ---------------------
* TRADE_TRANSACTION - TRADE_SETTLEMENT
* ---------------------
  ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-INVOICE_CURRENCYCODE-VALUE = IS_ETAX_DATA-WAERS.

* TRADE_TAX
  ASSIGN_ETAX_TAX(
    EXPORTING
      IF_VATBS_AMT = IS_ETAX_DATA-VATBS_AMT
      IF_VAT_AMT   = IS_ETAX_DATA-VAT_AMT
      IF_WAERS     = IS_ETAX_DATA-WAERS
      IF_TAXTY     = IS_ETAX_DATA-TAXTY
      IF_TAXRATE   = IS_ETAX_DATA-TAXRATE
    CHANGING
      CT_TRADE_TAX = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_TAX ).

* TRADE_ALLOWANCE_CHARGE
  LOOP AT IS_ETAX_DATA-CHRG_TAB ASSIGNING FIELD-SYMBOL(<L_CHRG_TAB>)
                                WHERE CHRG_AMT IS NOT INITIAL.
    CLEAR LT_AMOUNT1.
    WRITE <L_CHRG_TAB>-CHRG_AMT TO LF_TEXT35 LEFT-JUSTIFIED NO-GROUPING
                                             CURRENCY IS_ETAX_DATA-WAERS.
    CONDENSE LF_TEXT35 NO-GAPS.
    INSERT LF_TEXT35 INTO TABLE LT_AMOUNT1.
    INSERT VALUE #( CHARGEINDICATOR   = <L_CHRG_TAB>-CHRG_IND
                    ACTUALAMOUNT      = LT_AMOUNT1
                    REASONCODE        = <L_CHRG_TAB>-DISC_CD
                    REASON            = <L_CHRG_TAB>-DESCP_TH )
           INTO TABLE ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_ALLOWANCE_CHARGE.
  ENDLOOP.

* TRADE_PAYMENT_TERMS
* Not for CN/DN
  IF IS_ETAX_DATA-DCGRP NE 'DCN'.
    CLEAR LT_DESC.
    LF_TEXT256 = IS_ETAX_DATA-ZTERM_TXT.
    INSERT LF_TEXT256 INTO TABLE LT_DESC.

    LF_DATUM = IS_ETAX_DATA-DUEDT.
    ZCL_SDSCA_REST_INTF_UTILITY=>CONVERT_DATE_TIME_TO_ISO(
      EXPORTING
        IF_DATUM  = LF_DATUM
        IF_UZEIT  = '000000'
      IMPORTING
        EF_OUTPUT = LF_DATETIME ).

    INSERT VALUE #(
                    TYPECODE = ''
                    DESCRIPTION = LT_DESC
                    DUEDATETIME = LF_DATETIME
                    )
           INTO TABLE ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_PAYMENT_TERMS.
  ENDIF.

* TRADE_SETTLEMENT_HEADER-ORIGINAL_AMOUNT
*  IF IS_ETAX_DATA-ORG_AMT IS NOT INITIAL.
  IF IS_ETAX_DATA-DCGRP EQ 'DCN'.

    ASSIGN_ETAX_AMOUNT(
      EXPORTING
        IF_AMT      = IS_ETAX_DATA-ORG_AMT
        IF_CURRENCY = IS_ETAX_DATA-WAERS
      IMPORTING
        ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-ORIGINAL_AMOUNT ).
  ENDIF.

* TRADE_SETTLEMENT_HEADER-LINETOTAL_AMOUNT
  ASSIGN_ETAX_AMOUNT(
    EXPORTING
      IF_AMT      = IS_ETAX_DATA-NET1_AMT
      IF_CURRENCY = IS_ETAX_DATA-WAERS
    IMPORTING
      ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-LINETOTAL_AMOUNT ).

* TRADE_SETTLEMENT_HEADER-DIFFERENCE_AMOUNT
  IF IS_ETAX_DATA-DIFF_AMT IS NOT INITIAL.
    ASSIGN_ETAX_AMOUNT(
      EXPORTING
        IF_AMT      = IS_ETAX_DATA-DIFF_AMT
        IF_CURRENCY = IS_ETAX_DATA-WAERS
      IMPORTING
        ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-DIFFERENCE_AMOUNT ).
  ENDIF.

* TRADE_SETTLEMENT_HEADER-ALLOWANCETOTAL_AMOUNT
  IF IS_ETAX_DATA-ALLW_AMT IS NOT INITIAL.
    ASSIGN_ETAX_AMOUNT(
      EXPORTING
        IF_AMT      = IS_ETAX_DATA-ALLW_AMT
        IF_CURRENCY = IS_ETAX_DATA-WAERS
      IMPORTING
        ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-ALLOWANCETOTAL_AMOUNT ).
  ENDIF.

* TRADE_SETTLEMENT_HEADER-CHARGETOTAL_AMOUNT
  IF IS_ETAX_DATA-CHRG_AMT IS NOT INITIAL.
    ASSIGN_ETAX_AMOUNT(
      EXPORTING
        IF_AMT      = IS_ETAX_DATA-CHRG_AMT
        IF_CURRENCY = IS_ETAX_DATA-WAERS
      IMPORTING
        ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-CHARGETOTAL_AMOUNT ).
  ENDIF.

* TRADE_SETTLEMENT_HEADER-TAXBASISTOTAL_AMOUNT
  ASSIGN_ETAX_AMOUNT(
    EXPORTING
      IF_AMT      = IS_ETAX_DATA-VATBS_AMT
      IF_CURRENCY = IS_ETAX_DATA-WAERS
    IMPORTING
      ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-TAXBASISTOTAL_AMOUNT ).

* TRADE_SETTLEMENT_HEADER-TAXTOTAL_AMOUNT
  ASSIGN_ETAX_AMOUNT(
    EXPORTING
      IF_AMT      = IS_ETAX_DATA-VAT_AMT
      IF_CURRENCY = IS_ETAX_DATA-WAERS
    IMPORTING
      ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-TAXTOTAL_AMOUNT ).

* TRADE_SETTLEMENT_HEADER-GRANDTOTAL_AMOUNT
  IF IS_ETAX_DATA-NET2_AMT IS NOT INITIAL.
    ASSIGN_ETAX_AMOUNT(
      EXPORTING
        IF_AMT      = IS_ETAX_DATA-NET2_AMT
        IF_CURRENCY = IS_ETAX_DATA-WAERS
      IMPORTING
        ET_AMOUNT   = ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_SETTLEMENT-TRADE_SETTLEMENT_HEADER-GRANDTOTAL_AMOUNT ).
  ENDIF.

* INVOICER_TRADEPARTY
* INVOICEE_TRADEPARTY
* PAYER_TRADEPARTY
* PAYEE_TRADEPARTY

* ---------------------
* TRADE_TRANSACTION - TRADE_LINEITEM
* ---------------------
  LOOP AT IS_ETAX_DATA-ITEM ASSIGNING FIELD-SYMBOL(<L_ITEM>).

    ASSIGN_ETAX_ITEM(
      EXPORTING
        IS_DATA     = <L_ITEM>
      IMPORTING
        ES_LINEITEM = LS_LINEITEM ).

    INSERT LS_LINEITEM INTO TABLE ES_ETAX_SIGN-TRADE_TRANSACTION-TRADE_LINEITEM.

  ENDLOOP.

ENDMETHOD.


METHOD ASSIGN_ETAX_TAX.

  DATA:
    LT_AMOUNT1 TYPE ZSDSSDS063_TT,
    LT_AMOUNT2 TYPE ZSDSSDS063_TT.

  DATA:
    LF_TEXT35  TYPE  TEXT35.


  CLEAR LT_AMOUNT1.
  WRITE IF_VATBS_AMT TO LF_TEXT35 LEFT-JUSTIFIED NO-GROUPING
                                  CURRENCY IF_WAERS.
  CONDENSE LF_TEXT35 NO-GAPS.
  INSERT LF_TEXT35 INTO TABLE LT_AMOUNT1.

  CLEAR LT_AMOUNT2.
  WRITE IF_VAT_AMT TO LF_TEXT35 LEFT-JUSTIFIED NO-GROUPING
                                CURRENCY IF_WAERS.
  CONDENSE LF_TEXT35 NO-GAPS.
  INSERT LF_TEXT35 INTO TABLE LT_AMOUNT2.

  WRITE IF_TAXRATE TO LF_TEXT35 LEFT-JUSTIFIED NO-GROUPING DECIMALS 0.
  CONDENSE LF_TEXT35 NO-GAPS.

  INSERT VALUE #( TYPECODE         = IF_TAXTY
                  CALCULATEDRATE   = LF_TEXT35
                  BASISAMOUNT      = LT_AMOUNT1
                  CALCULATEDAMOUNT = LT_AMOUNT2 )
         INTO TABLE CT_TRADE_TAX.

ENDMETHOD.


METHOD ASSIGN_ITEM_DESCP.

  CONSTANTS:
    LC_TDID     TYPE  THEAD-TDID VALUE 'ZI06',
    LC_TDOBJECT TYPE  THEAD-TDOBJECT VALUE 'VBBP'.

  DATA:
    LT_LINE     TYPE STANDARD TABLE OF TLINE.

  DATA:
    LF_TDNAME  TYPE  THEAD-TDNAME,
    LF_TEXT    TYPE  TEXT100,
    LF_QTY     TYPE  TEXT50,
    LF_FPROZ_C TYPE CHAR6,
    LF_INT     TYPE N  LENGTH 3,
    LF_DEC     TYPE N  LENGTH 2,
    LF_INDEX   TYPE SY-TABIX.


* Initialize Output
  CLEAR EF_DESCP.

* ----------------
* Get Item Text
* ----------------
  LF_TDNAME   = |{ IS_ITEM-VBELN }{ IS_ITEM-POSNR }|.
  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      ID                      = LC_TDID
      LANGUAGE                = SY-LANGU
      NAME                    = LF_TDNAME
      OBJECT                  = LC_TDOBJECT
    TABLES
      LINES                   = LT_LINE
    EXCEPTIONS
      ID                      = 1
      LANGUAGE                = 2
      NAME                    = 3
      NOT_FOUND               = 4
      OBJECT                  = 5
      REFERENCE_CHECK         = 6
      WRONG_ACCESS_TO_ARCHIVE = 7
      OTHERS                  = 8.
  IF SY-SUBRC NE 0.
    CALL FUNCTION 'READ_TEXT'
      EXPORTING
        ID                      = LC_TDID
        LANGUAGE                = '2'
        NAME                    = LF_TDNAME
        OBJECT                  = LC_TDOBJECT
      TABLES
        LINES                   = LT_LINE
      EXCEPTIONS
        ID                      = 1
        LANGUAGE                = 2
        NAME                    = 3
        NOT_FOUND               = 4
        OBJECT                  = 5
        REFERENCE_CHECK         = 6
        WRONG_ACCESS_TO_ARCHIVE = 7
        OTHERS                  = 8.
    IF SY-SUBRC NE 0.
      CLEAR LT_LINE.
    ENDIF.
  ENDIF.

  READ TABLE LT_LINE ASSIGNING FIELD-SYMBOL(<L_LINE>)
                     INDEX 1.
  IF SY-SUBRC EQ 0.
    EF_DESCP  = <L_LINE>-TDLINE.
  ELSE.
    EF_DESCP = IS_ITEM-ARKTX.
  ENDIF.

* ----------------
* Billing Plan
* ----------------
  SELECT B~FPLNR,
         B~FPLTR,
         B~FKDAT,
         B~AFDAT,
         B~FPROZ
    FROM VBKD AS A
           INNER JOIN FPLT AS B
             ON  B~FPLNR = A~FPLNR
   WHERE A~VBELN EQ @IS_ITEM-AUBEL
     AND A~POSNR EQ @IS_ITEM-AUPOS
   ORDER BY B~AFDAT ASCENDING,
            B~FKDAT ASCENDING
    INTO TABLE @DATA(LT_BILLPLAN).
  IF SY-SUBRC NE 0.
    CLEAR LT_BILLPLAN.
  ENDIF.
  READ TABLE LT_BILLPLAN ASSIGNING FIELD-SYMBOL(<L_BILLPLAN>)
                         WITH KEY AFDAT = IS_BILL-FKDAT
                         BINARY SEARCH.
  IF SY-SUBRC EQ 0.
    LF_INDEX    = SY-TABIX.
    LF_FPROZ_C  = <L_BILLPLAN>-FPROZ.
    SPLIT LF_FPROZ_C AT '.' INTO LF_INT LF_DEC.
    IF LF_DEC IS INITIAL.
      LF_FPROZ_C  = LF_INT.
    ENDIF.
    EF_DESCP = |{ EF_DESCP } (งวดที่{ LF_INDEX  } { LF_FPROZ_C }%)|.
  ENDIF.

* ----------------
* BOM Items
* ----------------
  CLEAR LF_TEXT.
  LOOP AT IT_ITEM ASSIGNING FIELD-SYMBOL(<L_ITEM>)
                  WHERE VBELN EQ IS_ITEM-VBELN
                    AND UEPOS EQ IS_ITEM-POSNR.

    IF GR_NOSHOW_MATNR IS NOT INITIAL AND
       <L_ITEM>-MATNR IN GR_NOSHOW_MATNR.
      CONTINUE.
    ENDIF.

    WRITE <L_ITEM>-FKIMG TO LF_QTY UNIT <L_ITEM>-VRKME LEFT-JUSTIFIED NO-GROUPING.
    CONDENSE LF_QTY NO-GAPS.

    IF LF_TEXT IS INITIAL.
      LF_TEXT = |{ <L_ITEM>-MATNR }({ LF_QTY })|.
    ELSE.
      LF_TEXT = |{ LF_TEXT }+{ <L_ITEM>-MATNR }({ LF_QTY })|.
    ENDIF.

  ENDLOOP.

  EF_DESCP = |{ EF_DESCP } { LF_TEXT }|.

ENDMETHOD.


METHOD ASSIGN_TRADEPARTY.

  CONSTANTS:
    LC_MAX  TYPE  I VALUE 256.

  DATA:
    LS_TRADEPARTY TYPE ZSDSSDS069.

  DATA:
    LF_TEXT35 TYPE  TEXT35,
    LF_LEN    TYPE  I.

  FIELD-SYMBOLS:
    <L_LINE>  TYPE  ZSDSSDS069-POSTALTRADEADDRESS-LINEONE.


* Initialize Output
  CLEAR: ES_TRADEPARTY.

* ID
  LF_TEXT35 = IF_ID.
  INSERT LF_TEXT35 INTO TABLE LS_TRADEPARTY-ID.

* Name
  LS_TRADEPARTY-NAME = |{ IS_ADRC-NAME1 }{ IS_ADRC-NAME2 }{ IS_ADRC-NAME3 }{ IS_ADRC-NAME4 }|.

* Branch
  IF IF_BRANCH_TX IS NOT INITIAL.
    LS_TRADEPARTY-NAME = |{ LS_TRADEPARTY-NAME } { IF_BRANCH_TX }|.
    IF IF_BRANCH NE '00000'.
      LS_TRADEPARTY-NAME = |{ LS_TRADEPARTY-NAME }({ IF_BRANCH })|.
    ENDIF.
  ENDIF.

* Determine Tax ID Scheme
  IF IF_TAXID EQ '0000000000000'.
    LS_TRADEPARTY-TAX_REGISTRATION-ID-SCHEMEID = 'OTHR'.
*   TaxID
    LS_TRADEPARTY-TAX_REGISTRATION-ID-VALUE  = 'N/A'.
  ELSEIF IF_BRANCH IS INITIAL OR
         IF_BRANCH EQ 'NVAT'.
    LS_TRADEPARTY-TAX_REGISTRATION-ID-SCHEMEID = 'NIDN'.
*   TaxID
    LS_TRADEPARTY-TAX_REGISTRATION-ID-VALUE  = IF_TAXID.
  ELSE.
    LS_TRADEPARTY-TAX_REGISTRATION-ID-SCHEMEID = 'TXID'.
*   TaxID
    LS_TRADEPARTY-TAX_REGISTRATION-ID-VALUE  = |{ IF_TAXID }{ IF_BRANCH }|.
  ENDIF.

* Address
  LS_TRADEPARTY-POSTALTRADEADDRESS-POSTCODECODE = IS_ADRC-POST_CODE1.

  ASSIGN LS_TRADEPARTY-POSTALTRADEADDRESS-LINEONE TO <L_LINE>.
  IF IS_ADRC-STREET IS NOT INITIAL.
    MC_CONCAT <L_LINE> IS_ADRC-STREET.
  ENDIF.

  IF IS_ADRC-STR_SUPPL3 IS NOT INITIAL.
    MC_CONCAT <L_LINE> IS_ADRC-STR_SUPPL3.
  ENDIF.

  IF IS_ADRC-LOCATION IS NOT INITIAL.
    MC_CONCAT <L_LINE> IS_ADRC-LOCATION.
  ENDIF.

  IF IS_ADRC-STR_SUPPL1 IS NOT INITIAL.
    MC_CONCAT <L_LINE> IS_ADRC-STR_SUPPL1.
  ENDIF.

  IF IS_ADRC-STR_SUPPL2 IS NOT INITIAL.
    MC_CONCAT <L_LINE> IS_ADRC-STR_SUPPL2.
  ENDIF.

  IF IS_ADRC-CITY2 IS NOT INITIAL.
    MC_CONCAT <L_LINE> IS_ADRC-CITY2.
  ENDIF.

  IF IS_ADRC-CITY1 IS NOT INITIAL.
    MC_CONCAT <L_LINE> IS_ADRC-CITY1.
  ENDIF.

  LS_TRADEPARTY-POSTALTRADEADDRESS-COUNTRYID-VALUE = IS_ADRC-COUNTRY.

  GET_CNTY_SCHEME(
    EXPORTING
      IF_LAND1     = IS_ADRC-COUNTRY
    IMPORTING
      EF_SCHEMA_ID = LS_TRADEPARTY-POSTALTRADEADDRESS-COUNTRYID-SCHEMEID ).

  LS_TRADEPARTY-POSTALTRADEADDRESS-COUNTRYSUBDIVISIONID = IS_RD_ADDR-COUNTRYSUBDIVISIONID.
  LS_TRADEPARTY-POSTALTRADEADDRESS-CITYNAME             = IS_RD_ADDR-CITYNAME.
  LS_TRADEPARTY-POSTALTRADEADDRESS-CITYSUBDIVISIONNAME  = IS_RD_ADDR-CITYSUBDIVISIONNAME.
  LS_TRADEPARTY-POSTALTRADEADDRESS-BUILDINGNUMBER       = IS_RD_ADDR-BUILDINGNUMBER.

* Assign Output
  ES_TRADEPARTY = LS_TRADEPARTY.

ENDMETHOD.


METHOD CALL_CANCEL_SERVICE.

  DATA:
    LS_CONF    TYPE  TS_CONFIG,
    LS_LOG     TYPE  TS_LOG,
    LS_REQUEST TYPE  ZSDSSDS109.


* Initialize output
  CLEAR: ES_RESPONSE,
         ES_RETURN.

* Get ETax Configuration
  LS_CONF = GET_CONFIG( GF_ETXID ).
  IF LS_CONF IS INITIAL.
*   Error: Invalid Interface number.
    ES_RETURN-TYPE        = 'E'.
    ES_RETURN-ID          = 'ZSDSCA01'.
    ES_RETURN-NUMBER      = '013'.
    MESSAGE ID ES_RETURN-ID TYPE ES_RETURN-TYPE
            NUMBER ES_RETURN-NUMBER
            INTO ES_RETURN-MESSAGE.
    RETURN.
  ENDIF.

* Lock for Processing
  LOCK_PROCESSING(
    EXPORTING
      IF_BUKRS  = IS_ETAX_CANC-BUKRS
      IF_GJAHR  = IS_ETAX_CANC-GJAHR
      IF_DOCTY  = IS_ETAX_CANC-DOCTY
      IF_TAXINV = IS_ETAX_CANC-TAXINV
    IMPORTING
      ES_RETURN = ES_RETURN ).
  IF ES_RETURN IS NOT INITIAL.
    RETURN.
  ENDIF.

  DO 1 TIMES.
*   Log Processing Time
    CLEAR LS_LOG.
    LS_LOG-USNAM = SY-UNAME.
    LS_LOG-STDAT = SY-DATUM.
    LS_LOG-STTIM = SY-UZEIT.

*   Assign Specific KEYDATA for the calling
    LS_LOG-BUKRS   = IS_ETAX_CANC-BUKRS.
    LS_LOG-DOCTY   = IS_ETAX_CANC-DOCTY.
    LS_LOG-TAXINV  = IS_ETAX_CANC-TAXINV.
*    LS_LOG-SEQNO   =
    LS_LOG-VBELN   = IS_ETAX_CANC-VBELN.
    LS_LOG-BELNR   = IS_ETAX_CANC-BELNR.
    LS_LOG-GJAHR   = IS_ETAX_CANC-GJAHR.
    LS_LOG-CANCEL  = 'X'.

*   Assign Data Into Request Structure
    ASSIGN_ETAX_CANCEL(
      EXPORTING
        IS_DATA      = IS_ETAX_CANC
      IMPORTING
        ES_ETAX_CANC = LS_REQUEST ).

*   Convert Request Into JSON String
    TRANSFORM_DATA_TO_JSON(
      EXPORTING
        IF_TRANSFORM    = GF_TRN_CANC_REQ
        IS_DATA         = LS_REQUEST
      IMPORTING
        EF_JSON         = LS_LOG-REQUEST_JSON
      EXCEPTIONS
        TRANSFORM_ERROR = 1
        OTHERS          = 2 ).
    IF SY-SUBRC NE 0.
      ES_RETURN-TYPE        = 'E'.
      ES_RETURN-ID          = SY-MSGID.
      ES_RETURN-NUMBER      = SY-MSGNO.
      ES_RETURN-MESSAGE_V1  = SY-MSGV1.
      ES_RETURN-MESSAGE_V2  = SY-MSGV2.
      ES_RETURN-MESSAGE_V3  = SY-MSGV3.
      ES_RETURN-MESSAGE_V4  = SY-MSGV4.
      MESSAGE ID SY-MSGID TYPE SY-MSGTY
              NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
              INTO ES_RETURN-MESSAGE.
      EXIT.
    ENDIF.

*   Consume REST API
    CONSUME_REST_API(
      EXPORTING
        IF_TYPE          = GC_API_CANC
        IS_CONF          = LS_CONF
        IF_REQUEST_JSON  = LS_LOG-REQUEST_JSON
      IMPORTING
        EF_RESPONSE_JSON = LS_LOG-RESPONSE_JSON
        EF_HTTP_CODE     = LS_LOG-HTTP_CODE
        EF_HTTP_REASON   = LS_LOG-HTTP_REASON
        EF_HTML_ERROR    = LS_LOG-HTML_ERROR ).

*   Update Processing Time
    LS_LOG-ENDAT = SY-DATUM.
    LS_LOG-ENTIM = SY-UZEIT.

    IF LS_LOG-RESPONSE_JSON IS NOT INITIAL.
      TRANSFORM_JSON_TO_DATA(
        EXPORTING
          IF_TRANSFORM    = GF_TRN_CANC_RESP
          IF_JSON         = LS_LOG-RESPONSE_JSON
        IMPORTING
          ES_DATA         = ES_RESPONSE
        EXCEPTIONS
          TRANSFORM_ERROR = 1
          OTHERS          = 2 ).
      IF SY-SUBRC <> 0.
        ES_RETURN-TYPE        = 'E'.
        ES_RETURN-ID          = SY-MSGID.
        ES_RETURN-NUMBER      = SY-MSGNO.
        ES_RETURN-MESSAGE_V1  = SY-MSGV1.
        ES_RETURN-MESSAGE_V2  = SY-MSGV2.
        ES_RETURN-MESSAGE_V3  = SY-MSGV3.
        ES_RETURN-MESSAGE_V4  = SY-MSGV4.
        MESSAGE ID SY-MSGID TYPE SY-MSGTY
                NUMBER SY-MSGNO
                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
                INTO ES_RETURN-MESSAGE.
      ELSE.
        LS_LOG-STATUS  = ES_RESPONSE-RESPONSE_CODE.
        LS_LOG-MESSAGE = ES_RESPONSE-RESPONSE_MSG.
      ENDIF.

    ENDIF.

*   Default Error Message
    IF LS_LOG-HTTP_CODE NE '200' AND
       LS_LOG-STATUS IS INITIAL AND
       LS_LOG-MESSAGE IS INITIAL.
      LS_LOG-STATUS  = 'E'.
*     Text-e01: HTPP Error
      LS_LOG-MESSAGE = TEXT-E01.
    ENDIF.

*   Save Processing Log
    SAVE_PROCESSING_LOG(
      EXPORTING
        IS_LOG    = LS_LOG
      EXCEPTIONS
        LOG_ERROR = 1
        OTHERS    = 2 ).
    IF SY-SUBRC NE 0.
      ES_RETURN-TYPE        = 'E'.
      ES_RETURN-ID          = SY-MSGID.
      ES_RETURN-NUMBER      = SY-MSGNO.
      ES_RETURN-MESSAGE_V1  = SY-MSGV1.
      ES_RETURN-MESSAGE_V2  = SY-MSGV2.
      ES_RETURN-MESSAGE_V3  = SY-MSGV3.
      ES_RETURN-MESSAGE_V4  = SY-MSGV4.
      MESSAGE ID SY-MSGID TYPE SY-MSGTY
              NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
              INTO ES_RETURN-MESSAGE.
      EXIT.
    ENDIF.

  ENDDO.

  UNLOCK_PROCESSING(
    EXPORTING
      IF_BUKRS  = IS_ETAX_CANC-BUKRS
      IF_GJAHR  = IS_ETAX_CANC-GJAHR
      IF_DOCTY  = IS_ETAX_CANC-DOCTY
      IF_TAXINV = IS_ETAX_CANC-TAXINV ).

ENDMETHOD.


METHOD CALL_SIGN_SERVICE.

  DATA:
    LS_CONF    TYPE  TS_CONFIG,
    LS_LOG     TYPE  TS_LOG,
    LS_REQUEST TYPE  ZSDSSDS061.


* Initialize output
  CLEAR: ES_RESPONSE,
         ES_RETURN.

* Get ETax Configuration
  LS_CONF = GET_CONFIG( GF_ETXID ).
  IF LS_CONF IS INITIAL.
*   Error: Invalid Interface number.
    ES_RETURN-TYPE        = 'E'.
    ES_RETURN-ID          = 'ZSDSCA01'.
    ES_RETURN-NUMBER      = '013'.
    MESSAGE ID ES_RETURN-ID TYPE ES_RETURN-TYPE
            NUMBER ES_RETURN-NUMBER
            INTO ES_RETURN-MESSAGE.
    RETURN.
  ENDIF.

* Lock for Processing
  LOCK_PROCESSING(
    EXPORTING
      IF_BUKRS  = IS_ETAX_DATA-BUKRS
      IF_GJAHR  = IS_ETAX_DATA-GJAHR
      IF_DOCTY  = IS_ETAX_DATA-DOCTY
      IF_TAXINV = IS_ETAX_DATA-TAXINV
    IMPORTING
      ES_RETURN = ES_RETURN ).
  IF ES_RETURN IS NOT INITIAL.
    RETURN.
  ENDIF.

  DO 1 TIMES.
*   Log Processing Time
    CLEAR LS_LOG.
    LS_LOG-USNAM = SY-UNAME.
    LS_LOG-STDAT = SY-DATUM.
    LS_LOG-STTIM = SY-UZEIT.

*   Assign Specific KEYDATA for the calling
    LS_LOG-BUKRS   = IS_ETAX_DATA-BUKRS.
    LS_LOG-DOCTY   = IS_ETAX_DATA-DOCTY.
    LS_LOG-TAXINV  = IS_ETAX_DATA-TAXINV.
*    LS_LOG-SEQNO   =
    LS_LOG-VBELN   = IS_ETAX_DATA-VBELN.
    LS_LOG-BELNR   = IS_ETAX_DATA-BELNR.
    LS_LOG-GJAHR   = IS_ETAX_DATA-GJAHR.

*   Assign Data Into Request Structure
    ASSIGN_ETAX_SIGN(
      EXPORTING
        IS_ETAX_DATA = IS_ETAX_DATA
      IMPORTING
        ES_ETAX_SIGN = LS_REQUEST ).

*   Convert Request Into JSON String
    TRANSFORM_DATA_TO_JSON(
      EXPORTING
        IF_TRANSFORM    = GF_TRN_SIGN_REQ
        IS_DATA         = LS_REQUEST
      IMPORTING
        EF_JSON         = LS_LOG-REQUEST_JSON
      EXCEPTIONS
        TRANSFORM_ERROR = 1
        OTHERS          = 2 ).
    IF SY-SUBRC NE 0.
      ES_RETURN-TYPE        = 'E'.
      ES_RETURN-ID          = SY-MSGID.
      ES_RETURN-NUMBER      = SY-MSGNO.
      ES_RETURN-MESSAGE_V1  = SY-MSGV1.
      ES_RETURN-MESSAGE_V2  = SY-MSGV2.
      ES_RETURN-MESSAGE_V3  = SY-MSGV3.
      ES_RETURN-MESSAGE_V4  = SY-MSGV4.
      MESSAGE ID SY-MSGID TYPE SY-MSGTY
              NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
              INTO ES_RETURN-MESSAGE.
      EXIT.
    ENDIF.

*   Consume REST API
    CONSUME_REST_API(
      EXPORTING
        IF_TYPE          = GC_API_SIGN
        IS_CONF          = LS_CONF
        IF_REQUEST_JSON  = LS_LOG-REQUEST_JSON
      IMPORTING
        EF_RESPONSE_JSON = LS_LOG-RESPONSE_JSON
        EF_HTTP_CODE     = LS_LOG-HTTP_CODE
        EF_HTTP_REASON   = LS_LOG-HTTP_REASON
        EF_HTML_ERROR    = LS_LOG-HTML_ERROR ).

*   Update Processing Time
    LS_LOG-ENDAT = SY-DATUM.
    LS_LOG-ENTIM = SY-UZEIT.

    IF LS_LOG-RESPONSE_JSON IS NOT INITIAL.
      TRANSFORM_JSON_TO_DATA(
        EXPORTING
          IF_TRANSFORM    = GF_TRN_SIGN_RESP
          IF_JSON         = LS_LOG-RESPONSE_JSON
        IMPORTING
          ES_DATA         = ES_RESPONSE
        EXCEPTIONS
          TRANSFORM_ERROR = 1
          OTHERS          = 2 ).
      IF SY-SUBRC <> 0.
        ES_RETURN-TYPE        = 'E'.
        ES_RETURN-ID          = SY-MSGID.
        ES_RETURN-NUMBER      = SY-MSGNO.
        ES_RETURN-MESSAGE_V1  = SY-MSGV1.
        ES_RETURN-MESSAGE_V2  = SY-MSGV2.
        ES_RETURN-MESSAGE_V3  = SY-MSGV3.
        ES_RETURN-MESSAGE_V4  = SY-MSGV4.
        MESSAGE ID SY-MSGID TYPE SY-MSGTY
                NUMBER SY-MSGNO
                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
                INTO ES_RETURN-MESSAGE.
      ELSE.
        LS_LOG-STATUS  = ES_RESPONSE-RESPONSE_CODE.
        LS_LOG-MESSAGE = ES_RESPONSE-RESPONSE_MSG.
      ENDIF.

    ENDIF.

*   Default Error Message
    IF LS_LOG-HTTP_CODE NE '200' AND
       LS_LOG-STATUS IS INITIAL AND
       LS_LOG-MESSAGE IS INITIAL.
      LS_LOG-STATUS  = 'E'.
*     Text-e01: HTPP Error
      LS_LOG-MESSAGE = TEXT-E01.
    ENDIF.

*   Save Processing Log
    SAVE_PROCESSING_LOG(
      EXPORTING
        IS_LOG    = LS_LOG
      EXCEPTIONS
        LOG_ERROR = 1
        OTHERS    = 2 ).
    IF SY-SUBRC NE 0.
      ES_RETURN-TYPE        = 'E'.
      ES_RETURN-ID          = SY-MSGID.
      ES_RETURN-NUMBER      = SY-MSGNO.
      ES_RETURN-MESSAGE_V1  = SY-MSGV1.
      ES_RETURN-MESSAGE_V2  = SY-MSGV2.
      ES_RETURN-MESSAGE_V3  = SY-MSGV3.
      ES_RETURN-MESSAGE_V4  = SY-MSGV4.
      MESSAGE ID SY-MSGID TYPE SY-MSGTY
              NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
              INTO ES_RETURN-MESSAGE.
      EXIT.
    ENDIF.

  ENDDO.

  UNLOCK_PROCESSING(
    EXPORTING
      IF_BUKRS  = IS_ETAX_DATA-BUKRS
      IF_GJAHR  = IS_ETAX_DATA-GJAHR
      IF_DOCTY  = IS_ETAX_DATA-DOCTY
      IF_TAXINV = IS_ETAX_DATA-TAXINV ).

ENDMETHOD.


METHOD CONSUME_REST_API.

  DATA:
    LREF_CLIENT  TYPE REF TO IF_HTTP_CLIENT.

  DATA:
    LF_URL         TYPE STRING,
    LF_METHOD      TYPE CHAR1,
    LF_ENCODED     TYPE STRING,
    LF_USERID      TYPE STRING,
    LF_PASSWD      TYPE STRING,
    LF_HTTP_CODE   TYPE I,
    LF_HTTP_REASON TYPE STRING,
    LF_ERROR       TYPE FLAG.


* Initialize Output
  CLEAR: EF_RESPONSE_JSON,
         EF_HTTP_CODE,
         EF_HTTP_REASON,
         EF_HTML_ERROR.

* Create URL
  CASE IF_TYPE.
    WHEN GC_API_SIGN.
      LF_URL = IS_CONF-URI_SIGN.
      LF_METHOD = GC_POST.
    WHEN GC_API_CANC.
      LF_URL = IS_CONF-URI_CANC.
      LF_METHOD = GC_POST.
  ENDCASE.

  CALL METHOD CL_HTTP_CLIENT=>CREATE_BY_URL
    EXPORTING
      URL                = LF_URL
    IMPORTING
      CLIENT             = LREF_CLIENT
    EXCEPTIONS
      ARGUMENT_NOT_FOUND = 1
      PLUGIN_NOT_ACTIVE  = 2
      INTERNAL_ERROR     = 3
      OTHERS             = 4.
  IF SY-SUBRC NE 0.
*   Error: URL Error
    MESSAGE E017(ZSDSCA01) RAISING URL_ERROR.
    RETURN.
  ENDIF.

* Set Accept Cookies
  LREF_CLIENT->PROPERTYTYPE_ACCEPT_COOKIE = IF_HTTP_CLIENT=>CO_ENABLED.
  LREF_CLIENT->PROPERTYTYPE_LOGON_POPUP = IF_HTTP_CLIENT=>CO_DISABLED.

* Set Content JSON
  LREF_CLIENT->REQUEST->SET_HEADER_FIELD(
    EXPORTING
      NAME  = 'Content-Type' ##NO_TEXT
      VALUE = 'application/json' ).

* Only when User password provided
  IF NOT ( IS_CONF-USERNM IS INITIAL AND
           IS_CONF-PASSWD IS INITIAL ).
    CLEAR LF_PASSWD.
    IF IS_CONF-PASSWD IS NOT INITIAL.
*     Decrypt Password
      LF_ENCODED = IS_CONF-PASSWD.
      CALL METHOD CL_HTTP_UTILITY=>IF_HTTP_UTILITY~DECODE_BASE64
        EXPORTING
          ENCODED = LF_ENCODED
        RECEIVING
          DECODED = LF_PASSWD.
    ENDIF.

*   Basic Authentication with user/password
    LF_USERID = IS_CONF-USERNM.
    CALL METHOD LREF_CLIENT->AUTHENTICATE
      EXPORTING
        USERNAME = LF_USERID
        PASSWORD = LF_PASSWD.
  ENDIF.

* Set Call Method
  CASE LF_METHOD.
*   Get Method
    WHEN GC_GET.
      LREF_CLIENT->REQUEST->SET_METHOD( 'GET' ).
*   Post Method
    WHEN GC_POST.
      LREF_CLIENT->REQUEST->SET_METHOD( 'POST' ).
*   Default GET Method
    WHEN OTHERS.
      LREF_CLIENT->REQUEST->SET_METHOD( 'GET' ).
  ENDCASE.

* Set Data
  IF IF_REQUEST_JSON IS NOT INITIAL.
    LREF_CLIENT->REQUEST->SET_DATA(
      EXPORTING
        DATA = IF_REQUEST_JSON ).
  ENDIF.

* Send Request
  CALL METHOD LREF_CLIENT->SEND
*    EXPORTING
*      timeout                    = 200
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      HTTP_INVALID_TIMEOUT       = 4
      OTHERS                     = 5.
  IF SY-SUBRC <> 0.
*   Error: Error on Sending request.
    MESSAGE E018(ZSDSCA01) RAISING SEND_ERROR.
    RETURN.
  ENDIF.

* Recieve Response
  CALL METHOD LREF_CLIENT->RECEIVE
    EXCEPTIONS
      HTTP_COMMUNICATION_FAILURE = 1
      HTTP_INVALID_STATE         = 2
      HTTP_PROCESSING_FAILED     = 3
      OTHERS                     = 4.
  IF SY-SUBRC <> 0.
    LF_ERROR = 'X'.
  ENDIF.

* Get Response Status and Data
  CALL METHOD LREF_CLIENT->RESPONSE->GET_STATUS
    IMPORTING
      CODE   = LF_HTTP_CODE
      REASON = LF_HTTP_REASON.
  EF_HTTP_CODE   = LF_HTTP_CODE.
  EF_HTTP_REASON = LF_HTTP_REASON.

* Check Success code 200-299?
  IF ( NOT EF_HTTP_CODE BETWEEN 200 AND 299 ) OR ##NUMBER_OK
      LF_ERROR EQ 'X'.
    LF_ERROR = 'X'.
*   html result
    EF_HTML_ERROR = LREF_CLIENT->RESPONSE->GET_CDATA( ).
  ENDIF.

* Fetch data from API in json format
  EF_RESPONSE_JSON = LREF_CLIENT->RESPONSE->GET_DATA( ).

* Close Connection
  LREF_CLIENT->CLOSE( ).

ENDMETHOD.


METHOD CONVERT_BASE64_TO_BINARY.

* Initialize Output
  CLEAR: ET_BINARY,
         EF_XSTRING,
         EF_OUTPUT_LEN.

  CALL METHOD CL_HTTP_UTILITY=>DECODE_X_BASE64
    EXPORTING
      ENCODED = IF_BASE64
    RECEIVING
      DECODED = EF_XSTRING.

  IF ET_BINARY IS SUPPLIED.
    CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
      EXPORTING
        BUFFER        = EF_XSTRING
      IMPORTING
        OUTPUT_LENGTH = EF_OUTPUT_LEN
      TABLES
        BINARY_TAB    = ET_BINARY.
  ENDIF.

ENDMETHOD.


METHOD CONVERT_PDF_TO_BASE64.

  DATA:
    LT_BIN     TYPE  SOLIX_TAB.

  DATA:
    LF_FNAME    TYPE  STRING,
    LF_BIN      TYPE  SOLIX,
    LF_LEN      TYPE  I,
    LF_READ_LEN TYPE  I,
    LF_XSTRING  TYPE  XSTRING.


* Initialize Output
  CLEAR: EF_BASE64.

  LF_FNAME = IF_FNAME.

* Open Application Server file for Reading
  OPEN DATASET LF_FNAME FOR INPUT IN BINARY MODE.
  IF SY-SUBRC NE 0.
    RAISE READ_FILE_ERROR.
  ENDIF.

  CLEAR: LT_BIN,
         LF_LEN.
  DO.
    READ DATASET LF_FNAME INTO LF_BIN
                          LENGTH LF_READ_LEN.
    IF SY-SUBRC NE 0.
      EXIT.
    ELSE.
      LF_LEN = LF_LEN + LF_READ_LEN.
      INSERT LF_BIN INTO TABLE LT_BIN.
    ENDIF.
  ENDDO.

  CLOSE DATASET LF_FNAME.

  CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
    EXPORTING
      INPUT_LENGTH = LF_LEN
    IMPORTING
      BUFFER       = LF_XSTRING
    TABLES
      BINARY_TAB   = LT_BIN
    EXCEPTIONS
      FAILED       = 1
      OTHERS       = 2.
  IF SY-SUBRC <> 0.
    RAISE CONVERT_ERROR.
  ENDIF.

* Encode XString as Base64 format
  CALL METHOD CL_HTTP_UTILITY=>ENCODE_X_BASE64
    EXPORTING
      UNENCODED = LF_XSTRING
    RECEIVING
      ENCODED   = EF_BASE64.

ENDMETHOD.


METHOD GET_CAUSE_MAP.

  TYPES: BEGIN OF TS_MAP,
           AUGRU    TYPE  ZSDSSDC019-AUGRU,
           DOCTY    TYPE  ZSDSSDC019-DOCTY,
           CAUSE_CD TYPE ZSDSSDC019-CAUSE_CD,
           CAUSE_TX TYPE ZSDSSDC015-CAUSE_TX,
         END OF TS_MAP.
  TYPES: TT_MAP  TYPE  SORTED TABLE OF TS_MAP
                         WITH UNIQUE KEY AUGRU
                                         DOCTY.

  STATICS:
    LT_MAP TYPE TT_MAP,
    LS_MAP TYPE TS_MAP.


* Initialize Output
  CLEAR: EF_CAUSE_CD,
         EF_CAUSE_TX.

* Check Buffer
  IF IF_AUGRU NE LS_MAP-AUGRU OR
     IF_DOCTY NE LS_MAP-DOCTY.
*   Read from Memory
    READ TABLE LT_MAP INTO LS_MAP
                      WITH KEY AUGRU = IF_AUGRU
                               DOCTY = IF_DOCTY
                      BINARY SEARCH.
    IF SY-SUBRC NE 0.
*     Read From Database
      SELECT A~AUGRU,
             A~DOCTY,
             A~CAUSE_CD,
             B~CAUSE_TX
        FROM ZSDSSDC019 AS A
               LEFT OUTER JOIN ZSDSSDC015 AS B
                ON  B~CAUSE_CD = A~CAUSE_CD
       WHERE A~AUGRU EQ @IF_AUGRU
         AND A~DOCTY EQ @IF_DOCTY
       ORDER BY A~AUGRU ASCENDING,
                A~DOCTY ASCENDING
        INTO @LS_MAP
          UP TO 1 ROWS.
      ENDSELECT.
      IF SY-SUBRC NE 0.
        RETURN.
      ENDIF.
      INSERT LS_MAP INTO TABLE LT_MAP.
    ENDIF.
  ENDIF.

* Assign Result
  EF_CAUSE_CD = LS_MAP-CAUSE_CD.
  EF_CAUSE_TX = LS_MAP-CAUSE_TX.

ENDMETHOD.


METHOD GET_CNTY_SCHEME.

  TYPES: BEGIN OF TS_MAP,
           LAND1     TYPE ZSDSSDC020-LAND1,
           SCHEMA_ID TYPE ZSDSSDC020-SCHEMA_ID,
         END OF TS_MAP.
  TYPES: TT_MAP TYPE SORTED TABLE OF TS_MAP
                       WITH UNIQUE KEY LAND1.

  STATICS:
    LT_MAP  TYPE  TT_MAP.


* Initialize Output
  CLEAR: EF_SCHEMA_ID.

  IF LT_MAP IS INITIAL.
    SELECT LAND1
           SCHEMA_ID
      FROM ZSDSSDC020
      INTO TABLE LT_MAP.                                "#EC CI_NOWHERE
    IF SY-SUBRC NE 0.
      RETURN.
    ENDIF.
  ENDIF.

  READ TABLE LT_MAP ASSIGNING FIELD-SYMBOL(<L_MAP>)
                    WITH KEY LAND1 = IF_LAND1
                    BINARY SEARCH.
  IF SY-SUBRC NE 0.
    RETURN.
  ENDIF.

* Assign output
  EF_SCHEMA_ID = <L_MAP>-SCHEMA_ID.

ENDMETHOD.


METHOD GET_COMPANY_INFO.

*  DATA:
*    LT_TMP  TYPE  STANDARD TABLE OF TEXT1000,
*    LT_TEXT TYPE  STANDARD TABLE OF TEXT1000.

  DATA:
    LF_TEXT  TYPE  TEXT1000.


* Initialize Output
  CLEAR: RS_COMPANY.

* Get Company Property
  SELECT SINGLE BUKRS,
                BUTXT,
                STCEG,
                ADRNR
    FROM T001
   WHERE BUKRS EQ @IF_BUKRS
    INTO @DATA(LS_T001).
  IF SY-SUBRC NE 0.
    RETURN.
  ENDIF.

* Get Company Branch Address
  SELECT B~*
    FROM J_1BBRANCH AS A
           INNER JOIN ADRC AS B                        "#EC CI_BUFFJOIN
             ON  B~ADDRNUMBER = A~ADRNR
   WHERE A~BUKRS      EQ @IF_BUKRS
     AND A~BRANCH     EQ @IF_BRANCH
     AND A~BUPLA_TYPE EQ @SPACE
     AND B~NATION     EQ @SPACE
     AND B~DATE_FROM  LE @SY-DATUM
     AND B~DATE_TO    GE @SY-DATUM
   ORDER BY B~DATE_FROM ASCENDING,
            B~DATE_TO   ASCENDING
    INTO @DATA(LS_ADRC)
      UP TO 1 ROWS.
  ENDSELECT.
  IF SY-SUBRC NE 0.
    CLEAR LS_ADRC.
  ENDIF.

* Assign Output
  RS_COMPANY = CORRESPONDING #( LS_T001 ) ##ENH_OK.
  RS_COMPANY-ADRC = LS_ADRC.

* Province Code
  SELECT PROVINCE_CD
    FROM ZSDSSDC025
   WHERE POSTAL_FROM LE @LS_ADRC-POST_CODE1
     AND POSTAL_TO   GE @LS_ADRC-POST_CODE1
   ORDER BY PRIMARY KEY
    INTO @RS_COMPANY-ADDIT-COUNTRYSUBDIVISIONID
      UP TO 1 ROWS.
  ENDSELECT.
  IF SY-SUBRC NE 0.
    CLEAR RS_COMPANY-ADDIT-COUNTRYSUBDIVISIONID.
  ENDIF.

* Building Number (STREET)
  RS_COMPANY-ADDIT-BUILDINGNUMBER = LS_ADRC-STREET.

* District (CITY2)
  LF_TEXT = LS_ADRC-CITY2.
  REPLACE ALL OCCURRENCES OF 'เขต'  IN LF_TEXT WITH ''.
  REPLACE ALL OCCURRENCES OF 'อำเภอ'  IN LF_TEXT WITH ''.
  REPLACE ALL OCCURRENCES OF 'อ.'  IN LF_TEXT WITH ''.
  CONDENSE LF_TEXT.

  SELECT DISTRICT_CD
    FROM ZSDSSDC023
   WHERE PROVINCE_CD EQ @RS_COMPANY-ADDIT-COUNTRYSUBDIVISIONID
     AND DISTRICT_TX EQ @LF_TEXT
   ORDER BY PRIMARY KEY
    INTO @RS_COMPANY-ADDIT-CITYNAME
      UP TO 1 ROWS.
  ENDSELECT.
  IF SY-SUBRC NE 0.
    CLEAR RS_COMPANY-ADDIT-CITYNAME.
  ENDIF.

* Sub District (LOCATION)
  LF_TEXT = LS_ADRC-LOCATION.
  REPLACE ALL OCCURRENCES OF 'แขวง'  IN LF_TEXT WITH ''.
  REPLACE ALL OCCURRENCES OF 'ตำบล'  IN LF_TEXT WITH ''.
  REPLACE ALL OCCURRENCES OF 'ต.'  IN LF_TEXT WITH ''.
  CONDENSE LF_TEXT.

  SELECT SUBDISTR_CD
    FROM ZSDSSDC024
   WHERE PROVINCE_CD EQ @RS_COMPANY-ADDIT-COUNTRYSUBDIVISIONID
     AND DISTRICT_CD EQ @RS_COMPANY-ADDIT-CITYNAME
     AND SUBDISTR_TX EQ @LF_TEXT
   ORDER BY PRIMARY KEY
    INTO @RS_COMPANY-ADDIT-CITYSUBDIVISIONNAME
      UP TO 1 ROWS.
  ENDSELECT.
  IF SY-SUBRC NE 0.
    CLEAR RS_COMPANY-ADDIT-CITYSUBDIVISIONNAME.
  ENDIF.

*  CLEAR: LT_TEXT.
*  SPLIT LS_ADRC-STREET AT SPACE INTO TABLE LT_TEXT.
*  LOOP AT LT_TEXT ASSIGNING FIELD-SYMBOL(<L_TEXT>).
*    IF <L_TEXT> CO '0123456789/-, '.
*      RS_COMPANY-ADDIT-BUILDINGNUMBER       = <L_TEXT>.
*      EXIT.
*    ENDIF.
*  ENDLOOP.
*
** Full Address
*  DATA(LF_ADDRESS) = |{ LS_ADRC-STREET } { LS_ADRC-LOCATION } { LS_ADRC-CITY2 } { LS_ADRC-CITY1 }|.
*  CLEAR: LT_TMP,
*         LT_TEXT.
*  SPLIT LF_ADDRESS AT SPACE INTO TABLE LT_TMP.
*  DELETE LT_TMP WHERE TABLE_LINE IS INITIAL.
** Revert Order
*  DATA(LF_TIME) = LINES( LT_TMP ).
*  DATA(LF_INDX) = LF_TIME.
*  DO LF_TIME TIMES.
*    READ TABLE LT_TMP ASSIGNING <L_TEXT>
*                      INDEX LF_INDX.
*    IF SY-SUBRC EQ 0.
*      INSERT <L_TEXT> INTO TABLE LT_TEXT.
*    ENDIF.
*    LF_INDX = LF_INDX - 1.
*  ENDDO.
*  FREE LT_TMP.
*
*  LOOP AT LT_TEXT ASSIGNING <L_TEXT>.
*
**   District
*    IF RS_COMPANY-ADDIT-CITYNAME IS INITIAL.
*      REPLACE ALL OCCURRENCES OF 'เขต'  IN <L_TEXT> WITH ''.
*      REPLACE ALL OCCURRENCES OF 'อำเภอ'  IN <L_TEXT> WITH ''.
*      REPLACE ALL OCCURRENCES OF 'อ.'  IN <L_TEXT> WITH ''.
*
*      SELECT DISTRICT_CD
*        FROM ZSDSSDC023
*       WHERE PROVINCE_CD EQ @RS_COMPANY-ADDIT-COUNTRYSUBDIVISIONID
*         AND DISTRICT_TX EQ @<L_TEXT>
*       ORDER BY PRIMARY KEY
*        INTO @RS_COMPANY-ADDIT-CITYNAME
*          UP TO 1 ROWS.
*      ENDSELECT.
*      IF SY-SUBRC EQ 0.
*        CONTINUE.
*      ENDIF.
*
**   Sub District
*    ELSEIF RS_COMPANY-ADDIT-CITYSUBDIVISIONNAME IS INITIAL.
*      REPLACE ALL OCCURRENCES OF 'แขวง'  IN <L_TEXT> WITH ''.
*      REPLACE ALL OCCURRENCES OF 'ตำบล'  IN <L_TEXT> WITH ''.
*      REPLACE ALL OCCURRENCES OF 'ต.'  IN <L_TEXT> WITH ''.
*
*      SELECT SUBDISTR_CD
*        FROM ZSDSSDC024
*       WHERE PROVINCE_CD EQ @RS_COMPANY-ADDIT-COUNTRYSUBDIVISIONID
*         AND DISTRICT_CD EQ @RS_COMPANY-ADDIT-CITYNAME
*         AND SUBDISTR_TX EQ @<L_TEXT>
*       ORDER BY PRIMARY KEY
*        INTO @RS_COMPANY-ADDIT-CITYSUBDIVISIONNAME
*          UP TO 1 ROWS.
*      ENDSELECT.
*      IF SY-SUBRC EQ 0.
*        EXIT.
*      ENDIF.
*
*    ENDIF.
*
*  ENDLOOP.

ENDMETHOD.


METHOD GET_CONFIG.

  STATICS:
    LS_CONF  TYPE  TS_CONFIG.


* Initialize Output
  CLEAR RS_CONF.

  IF LS_CONF-ETXID NE IF_ETXID.
*   Read Configuration from DB
    SELECT SINGLE ETXID,
                  URI_AUTH,
                  URI_SIGN,
                  URI_CANC,
                  USERNM,
                  PASSWD,
                  CLIENTID
      FROM ZSDSSDC011
     WHERE ETXID EQ @IF_ETXID
      INTO @LS_CONF.
    IF SY-SUBRC NE 0.
      CLEAR LS_CONF.
      RETURN.
    ENDIF.

  ENDIF.

* Assign Output
  RS_CONF = LS_CONF.

ENDMETHOD.


METHOD GET_CONSTANTS.

  CONSTANTS:
    LC_EXCH_CNT_AGENCY  TYPE ZSDSDE_PARAM_NAME VALUE 'EXCH_CONTEXT_AGENCY',
    LC_EXCH_CNT_VERSION TYPE ZSDSDE_PARAM_NAME VALUE 'EXCH_CONTEXT_VERSION',
    LC_EXCH_CNT_VALUE   TYPE ZSDSDE_PARAM_NAME VALUE 'EXCH_CONTEXT_VALUE',
    LC_KSCHL_CHARGE     TYPE ZSDSDE_PARAM_NAME VALUE 'COND_TYPE_CHARGE',
    LC_KSCHL_DISCOUNT   TYPE ZSDSDE_PARAM_NAME VALUE 'COND_TYPE_DISCOUNT',
    LC_INTF_FORM        TYPE ZSDSDE_PARAM_NAME VALUE 'FORM_INTERFACE_ID',
    LC_KALSM_SUBTOT4    TYPE ZSDSDE_PARAM_NAME VALUE 'PRICE_PROC_SUBTOT4',
    LC_MATERIAL         TYPE ZSDSDE_PARAM_NAME VALUE 'MATERIAL',
    LC_DEFT_BUPLA       TYPE ZSDSDE_PARAM_NAME VALUE 'COMP_BRANCH_CHANNEL',
    LC_NEW_REF_START    TYPE ZSDSDE_PARAM_NAME VALUE 'NEW_REF_INFO_START',

    LC_CN_DOC_TYPE      TYPE ZSDSDE_PARAM_NAME VALUE 'CN_DOC_TYPE',
    LC_NO_DESC          TYPE ZSDSDE_PARAM_EXT  VALUE 'NOT_SHOW_MAT_DESC',
    LC_SPECIAL_ZUONR    TYPE ZSDSDE_PARAM_EXT  VALUE 'SPECIAL_ACC_ASSIGN'. "+420000252

  STATICS:
    LF_READ       TYPE  FLAG.

  DATA:
    LT_TMP  TYPE  ZCL_SDSCA_UTILITIES=>TT_GEN_C,
    LT_GENC TYPE  ZCL_SDSCA_UTILITIES=>TT_GEN_C.

  DATA:
    LF_REPID TYPE  PROGRAMM VALUE 'ZCL_SDSSD_ETAX_INTERFACE',
    LF_BUPLA TYPE  TS_DEFT_BUPLA-BUPLA.


* Check Already Read?
  IF LF_READ EQ 'X'.
    RETURN.
  ENDIF.

* Initialize Output
  CLEAR: GS_EXCH_CONTEXT,
         GR_KSCHL_CHARGE,
         GR_KSCHL_DISCOUNT,
         GT_INTF_FORM,
         GR_NOSHOW_MATNR,
         GR_KALSM_SUBTOT4,
         GT_DEFT_BUPLA,
         GR_FI_UMSKZ,
         GR_BLART_CN,
         GF_NEW_REF_START,
         GR_SPECIAL_ZUONR.                                  "+420000252

* Read All GenC constants for program
  CALL METHOD ZCL_SDSCA_UTILITIES=>GET_GEN_C
    EXPORTING
      IF_REPID = LF_REPID
    IMPORTING
      ET_GEN_C = LT_GENC.

* Read All GenC constants for program
  CALL METHOD ZCL_SDSCA_UTILITIES=>GET_GEN_C
    EXPORTING
      IF_REPID = 'ZSDSSDR0100'
    IMPORTING
      ET_GEN_C = LT_TMP.
  INSERT LINES OF LT_TMP INTO TABLE LT_GENC.
  CALL METHOD ZCL_SDSCA_UTILITIES=>GET_GEN_C
    EXPORTING
      IF_REPID = 'ZSDSFIR0210'
    IMPORTING
      ET_GEN_C = LT_TMP.
  INSERT LINES OF LT_TMP INTO TABLE LT_GENC.
  FREE LT_TMP.

* Mark Read Flag
  LF_READ = 'X'.

* Assign GenC Constants
  LOOP AT LT_GENC ASSIGNING FIELD-SYMBOL(<L_GENC>).

    CASE <L_GENC>-PARAM.
*     ------------------------------------
*     Exchanged Content Agency ID
*     ------------------------------------
      WHEN LC_EXCH_CNT_AGENCY.
        GS_EXCH_CONTEXT-SCHEME_AGENCY_ID = <L_GENC>-VALUE_LOW.

*     ------------------------------------
*     Exchanged Content version ID
*     ------------------------------------
      WHEN LC_EXCH_CNT_VERSION.
        GS_EXCH_CONTEXT-SCHEME_VERSION_ID = <L_GENC>-VALUE_LOW.

*     ------------------------------------
*     Exchanged Content Value
*     ------------------------------------
      WHEN LC_EXCH_CNT_VALUE.
        GS_EXCH_CONTEXT-VALUE = <L_GENC>-VALUE_LOW.

*     ------------------------------------
*     Condition Types: Charge
*     ------------------------------------
      WHEN LC_KSCHL_CHARGE.
        INSERT VALUE #( SIGN   = <L_GENC>-PARAM_SIGN
                        OPTION = <L_GENC>-PARAM_OPTION
                        LOW    = <L_GENC>-VALUE_LOW
                        HIGH   = <L_GENC>-VALUE_HIGH )
               INTO TABLE GR_KSCHL_CHARGE.

*     ------------------------------------
*     Condition Types: Discount
*     ------------------------------------
      WHEN LC_KSCHL_DISCOUNT.
        INSERT VALUE #( SIGN   = <L_GENC>-PARAM_SIGN
                        OPTION = <L_GENC>-PARAM_OPTION
                        LOW    = <L_GENC>-VALUE_LOW
                        HIGH   = <L_GENC>-VALUE_HIGH )
               INTO TABLE GR_KSCHL_DISCOUNT.

*     ------------------------------------
*     Interface Form Info
*     ------------------------------------
      WHEN LC_INTF_FORM.
        INSERT VALUE #( INTFNO     = <L_GENC>-VALUE_LOW
                        SAP_MODULE = <L_GENC>-PARAM_EXT )
               INTO TABLE GT_INTF_FORM.

*     ------------------------------------
*     Pricing Procedure uses amount from Subtotal4
*     ------------------------------------
      WHEN LC_KALSM_SUBTOT4.
        INSERT VALUE #( SIGN   = <L_GENC>-PARAM_SIGN
                        OPTION = <L_GENC>-PARAM_OPTION
                        LOW    = <L_GENC>-VALUE_LOW
                        HIGH   = <L_GENC>-VALUE_HIGH )
               INTO TABLE GR_KALSM_SUBTOT4.

*     ------------------------------------
*     Material Code without description
*     ------------------------------------
      WHEN LC_MATERIAL.
        IF <L_GENC>-PARAM_EXT EQ LC_NO_DESC.
          INSERT VALUE #( SIGN   = <L_GENC>-PARAM_SIGN
                          OPTION = <L_GENC>-PARAM_OPTION
                          LOW    = <L_GENC>-VALUE_LOW
                          HIGH   = <L_GENC>-VALUE_HIGH )
                 INTO TABLE GR_NOSHOW_MATNR.
        ENDIF.

*     ------------------------------------
*     Default Business Place from Dist Channel
*     ------------------------------------
      WHEN LC_DEFT_BUPLA.
        LF_BUPLA = <L_GENC>-PARAM_EXT.
        READ TABLE GT_DEFT_BUPLA ASSIGNING FIELD-SYMBOL(<L_DEFT_BUPLA>)
                                 WITH KEY BUPLA = LF_BUPLA
                                 BINARY SEARCH.
        IF SY-SUBRC NE 0.
          INSERT VALUE #( BUPLA = <L_GENC>-PARAM_EXT )
                 INTO TABLE GT_DEFT_BUPLA
                 ASSIGNING <L_DEFT_BUPLA>.
        ENDIF.
        INSERT VALUE #( SIGN   = <L_GENC>-PARAM_SIGN
                        OPTION = <L_GENC>-PARAM_OPTION
                        LOW    = <L_GENC>-VALUE_LOW
                        HIGH   = <L_GENC>-VALUE_HIGH )
               INTO TABLE <L_DEFT_BUPLA>-VTWEG.

*     ------------------------------------
*     Start date of new logic to get reference info
*     ------------------------------------
      WHEN LC_NEW_REF_START.
        GF_NEW_REF_START = <L_GENC>-VALUE_LOW.

*     ------------------------------------
*     CN Document Types
*     ------------------------------------
      WHEN LC_CN_DOC_TYPE.
        INSERT VALUE #( SIGN   = <L_GENC>-PARAM_SIGN
                        OPTION = <L_GENC>-PARAM_OPTION
                        LOW    = <L_GENC>-VALUE_LOW
                        HIGH   = <L_GENC>-VALUE_HIGH )
               INTO TABLE GR_BLART_CN.

*<-- Start of Insertion 420000252 14.07.2025 (New GenC)
*     ------------------------------------
*     Special processing Account Assignment
*     ------------------------------------
      WHEN LC_SPECIAL_ZUONR.
        INSERT VALUE #( SIGN   = <L_GENC>-PARAM_SIGN
                        OPTION = <L_GENC>-PARAM_OPTION
                        LOW    = <L_GENC>-VALUE_LOW
                        HIGH   = <L_GENC>-VALUE_HIGH )
               INTO TABLE GR_SPECIAL_ZUONR.
*--> End of Insertion 420000252  14.07.2025
    ENDCASE.

  ENDLOOP.

* Customer Item SP/GL Related
  INSERT VALUE #( SIGN = 'I' OPTION = 'EQ' LOW = ' ' ) INTO TABLE GR_FI_UMSKZ.
  INSERT VALUE #( SIGN = 'I' OPTION = 'EQ' LOW = 'S' ) INTO TABLE GR_FI_UMSKZ.

ENDMETHOD.


METHOD GET_CUSTOMER_INFO.

  TYPES: BEGIN OF TS_CUSTINFO,
           KUNNR TYPE  KNA1-KUNNR,
           INFO  TYPE  TS_CUSTOMER,
         END OF TS_CUSTINFO.
  TYPES: TT_CUSTINFO TYPE SORTED TABLE OF TS_CUSTINFO
                          WITH UNIQUE KEY KUNNR.

  CONSTANTS:
    LC_ONETIME TYPE  KNA1-KTOKD VALUE 'Z060',
    LC_PAYER   TYPE  VBPA-PARVW VALUE 'RG',
    LC_TAXTYPE TYPE  DFKKBPTAXNUM-TAXTYPE VALUE 'TH3'.

  STATICS:
    LT_CUSTINFO TYPE TT_CUSTINFO,
    LS_CUSTINFO TYPE TS_CUSTINFO.

  DATA:
    LF_EN TYPE  FITHA_PBUPL_D_T-DESCRIPTION,
    LF_TH TYPE  FITHA_PBUPL_D_T-DESCRIPTION.


* Initialize Output
  CLEAR: RS_CUSTOMER.

  IF IF_KUNNR NE LS_CUSTINFO-KUNNR.

    READ TABLE LT_CUSTINFO INTO LS_CUSTINFO
                           WITH KEY KUNNR = IF_KUNNR
                           BINARY SEARCH.
    IF SY-SUBRC NE 0.
*     Get Customer Properties
      SELECT SINGLE KUNNR,
                    NAME1,
                    NAME2,
                    STCD3,
                    KTOKD,
                    ADRNR
        FROM KNA1
       WHERE KUNNR EQ @IF_KUNNR
        INTO @DATA(LS_KNA1).
      IF SY-SUBRC NE 0.
        RETURN.
      ENDIF.

*     Read Tax Number from Partner if cannot find in customer master
      IF LS_KNA1-STCD3 IS INITIAL.
        SELECT TAXNUM
          FROM CVI_CUST_LINK AS A
                 INNER JOIN BUT000 AS B
                   ON  B~PARTNER_GUID = A~PARTNER_GUID
                 INNER JOIN DFKKBPTAXNUM AS C
                   ON  C~PARTNER = B~PARTNER
                   AND C~TAXTYPE = @LC_TAXTYPE
         WHERE A~CUSTOMER EQ @LS_KNA1-KUNNR
         ORDER BY A~PARTNER_GUID ASCENDING,
                  B~PARTNER      ASCENDING,
                  C~TAXTYPE      ASCENDING
          INTO @DATA(LF_TAXNUM)
            UP TO 1 ROWS.
        ENDSELECT.
        IF SY-SUBRC EQ 0.
          LS_KNA1-STCD3 = LF_TAXNUM.
        ENDIF.
      ENDIF.

      IF IF_J_1TPBUPL IS NOT INITIAL.
*       Get Branch
        SELECT A~J_1TPBUPL,
               B~DESCRIPTION
          FROM FITHA_PBUPL_D AS A
                 LEFT OUTER JOIN FITHA_PBUPL_D_T AS B
                  ON  B~SPRAS     = @SY-LANGU
                  AND B~KUNNR     = A~KUNNR
                  AND B~J_1TPBUPL = A~J_1TPBUPL
         WHERE A~KUNNR EQ @LS_KNA1-KUNNR
           AND A~J_1TPBUPL EQ @IF_J_1TPBUPL
         ORDER BY A~J_1TPBUPL ASCENDING
          INTO @DATA(LS_BRANCH)
            UP TO 1 ROWS.
        ENDSELECT.
        IF SY-SUBRC NE 0.
          CLEAR LS_BRANCH.
        ENDIF.
      ENDIF.
      IF LS_BRANCH IS INITIAL.
*       Get Default Branch
        SELECT A~J_1TPBUPL,
               B~DESCRIPTION
          FROM FITHA_PBUPL_D AS A
                 LEFT OUTER JOIN FITHA_PBUPL_D_T AS B
                  ON  B~SPRAS     = @SY-LANGU
                  AND B~KUNNR     = A~KUNNR
                  AND B~J_1TPBUPL = A~J_1TPBUPL
         WHERE A~KUNNR EQ @LS_KNA1-KUNNR
           AND A~DEFAULT_BRANCH EQ 'X'
         ORDER BY A~J_1TPBUPL ASCENDING
          INTO @LS_BRANCH
            UP TO 1 ROWS.
        ENDSELECT.
        IF SY-SUBRC NE 0.
          CLEAR LS_BRANCH.
        ENDIF.
      ENDIF.

      IF LS_KNA1-KTOKD EQ LC_ONETIME.

        IF IF_VBELN IS SUPPLIED.
          SELECT A~ADRNR,
                 B~STCD3
            FROM VBPA AS A
                   LEFT OUTER JOIN VBPA3 AS B
                     ON  B~VBELN = A~VBELN
                     AND B~POSNR = A~POSNR
                     AND B~PARVW = A~PARVW
           WHERE A~VBELN EQ @IF_VBELN
             AND A~POSNR EQ '000000'
             AND A~PARVW EQ @LC_PAYER
           ORDER BY A~VBELN ASCENDING,
                    A~POSNR ASCENDING,
                    A~PARVW ASCENDING
            INTO @DATA(LS_VBPA)
              UP TO 1 ROWS.
          ENDSELECT.
          IF SY-SUBRC EQ 0.
            LS_KNA1-ADRNR = LS_VBPA-ADRNR.
            IF LS_VBPA-STCD3 IS NOT INITIAL.
              LS_KNA1-STCD3 = LS_VBPA-STCD3.
            ENDIF.
          ENDIF.

        ENDIF.

      ENDIF.

      IF NOT ( IS_BSEC IS SUPPLIED AND
               IS_BSEC IS NOT INITIAL ).
*       Get Customer Address
        SELECT *                              "#EC CI_ALL_FIELDS_NEEDED
          FROM ADRC
         WHERE ADDRNUMBER EQ @LS_KNA1-ADRNR
           AND NATION     EQ @IF_NATION
           AND DATE_FROM  LE @SY-DATUM
           AND DATE_TO    GE @SY-DATUM
         ORDER BY PRIMARY KEY
          INTO @DATA(LS_ADRC)
            UP TO 1 ROWS.
        ENDSELECT.
        IF SY-SUBRC NE 0.
          CLEAR LS_ADRC.
        ENDIF.
*       Get Email
        SELECT SMTP_ADDR
          FROM ADR6
         WHERE ADDRNUMBER EQ @LS_ADRC-ADDRNUMBER
           AND DATE_FROM  EQ @LS_ADRC-DATE_FROM
         ORDER BY FLGDEFAULT DESCENDING,
                  HOME_FLAG  DESCENDING
          INTO @DATA(LF_EMAIL)
            UP TO 1 ROWS.
        ENDSELECT.
        IF SY-SUBRC NE 0.
          CLEAR LF_EMAIL.
        ENDIF.

      ELSE.
*       Name
        LS_ADRC-NAME1      = IS_BSEC-ANRED.
        LS_ADRC-NAME2      = IS_BSEC-NAME1.
        LS_ADRC-NAME3      = IS_BSEC-NAME2.
*       TaxID
        LS_KNA1-STCD3      = IS_BSEC-STCD3.
*       Address
        LS_ADRC-STREET     = IS_BSEC-STRAS.
        LS_ADRC-STR_SUPPL3 = IS_BSEC-NAME3.
        LS_ADRC-LOCATION   = IS_BSEC-NAME4.
*        LS_ADRC-STR_SUPPL1
*        LS_ADRC-STR_SUPPL2
        LS_ADRC-CITY2      = IS_BSEC-ORT01.
*        LS_ADRC-CITY1
        LS_ADRC-POST_CODE1 = IS_BSEC-PSTLZ.
        LS_ADRC-COUNTRY    = IS_BSEC-LAND1.
*       Email
        LF_EMAIL           = IS_BSEC-INTAD.
*        LS_ADRC-TEL_NUMBER

      ENDIF.

*     Collect Result
      CLEAR LS_CUSTINFO.
      LS_CUSTINFO-KUNNR = LS_KNA1-KUNNR.
      LS_CUSTINFO-INFO  = CORRESPONDING #( LS_KNA1 ) ##ENH_OK.
      LS_CUSTINFO-INFO-J_1TPBUPL = LS_BRANCH-J_1TPBUPL.
      CLEAR: LF_EN,
             LF_TH.
      SPLIT LS_BRANCH-DESCRIPTION AT '/' INTO LF_EN
                                              LF_TH.
      CASE LS_ADRC-NATION.
        WHEN 'I'.
          LS_CUSTINFO-INFO-DESCRIPTION = LF_EN.
        WHEN OTHERS.
          LS_CUSTINFO-INFO-DESCRIPTION = LF_TH.
      ENDCASE.
      LS_CUSTINFO-INFO-EMAIL = LF_EMAIL.
      LS_CUSTINFO-INFO-ADRC = LS_ADRC.

*     Etax Data
      IF LS_KNA1-KTOKD EQ LC_ONETIME.
        IF LF_EMAIL IS NOT INITIAL.
          LS_CUSTINFO-INFO-ETAX-REQ_SEND_MAIL = 'X'.
          LS_CUSTINFO-INFO-ETAX-EMAIL = LF_EMAIL.
        ENDIF.
        IF LS_ADRC-TEL_NUMBER IS NOT INITIAL.
*         Only Send SMS when no Email
          IF LF_EMAIL IS INITIAL.
            LS_CUSTINFO-INFO-ETAX-REQ_SEND_SMS = 'X'.
          ENDIF.
          LS_CUSTINFO-INFO-ETAX-MOBILE_NUMBER = LS_ADRC-TEL_NUMBER.
        ENDIF.

      ELSE.
*       Get E-Tax Customer Communication Info
        SELECT KUNNR,
               RUNNO,
               E_MAIL,
               MOBILE_PHONE
          FROM ZSDSFIC001
         WHERE KUNNR EQ @LS_KNA1-KUNNR
          ORDER BY RUNNO ASCENDING
          INTO TABLE @DATA(LT_CUSTCOM).
        IF SY-SUBRC EQ 0.
          LOOP AT LT_CUSTCOM ASSIGNING FIELD-SYMBOL(<L_CUSTCOM>).
            IF <L_CUSTCOM>-E_MAIL IS NOT INITIAL.
              LS_CUSTINFO-INFO-ETAX-REQ_SEND_MAIL = 'X'.
              IF LS_CUSTINFO-INFO-ETAX-EMAIL IS INITIAL.
                LS_CUSTINFO-INFO-ETAX-EMAIL = <L_CUSTCOM>-E_MAIL.
              ELSE.
                LS_CUSTINFO-INFO-ETAX-EMAIL = |{ LS_CUSTINFO-INFO-ETAX-EMAIL };{ <L_CUSTCOM>-E_MAIL }|.
              ENDIF.
            ENDIF.
            IF <L_CUSTCOM>-MOBILE_PHONE IS NOT INITIAL.
*             Not Send SMS for Normal Partner
              LS_CUSTINFO-INFO-ETAX-REQ_SEND_SMS = ' '.
              IF LS_CUSTINFO-INFO-ETAX-MOBILE_NUMBER IS INITIAL.
                LS_CUSTINFO-INFO-ETAX-MOBILE_NUMBER = <L_CUSTCOM>-MOBILE_PHONE.
              ELSE.
                LS_CUSTINFO-INFO-ETAX-MOBILE_NUMBER = |{ LS_CUSTINFO-INFO-ETAX-MOBILE_NUMBER };{ <L_CUSTCOM>-MOBILE_PHONE }|.
              ENDIF.
            ENDIF.
          ENDLOOP.
        ELSE.
          IF LS_CUSTINFO-INFO-EMAIL IS NOT INITIAL.
            LS_CUSTINFO-INFO-ETAX-REQ_SEND_MAIL = 'X'.
            LS_CUSTINFO-INFO-ETAX-EMAIL = LS_CUSTINFO-INFO-EMAIL.
          ENDIF.
        ENDIF.

        INSERT LS_CUSTINFO INTO TABLE LT_CUSTINFO.

      ENDIF.

    ENDIF.

  ENDIF.

* Assign Output
  RS_CUSTOMER = LS_CUSTINFO-INFO.

* Clear Buffer for Onetime
  IF LS_KNA1-KTOKD EQ LC_ONETIME.
    CLEAR LS_CUSTINFO.
  ENDIF.

ENDMETHOD.


METHOD GET_DATA_FI.

  CONSTANTS:
    LC_CUSTOMER  TYPE  BSEG-KOART VALUE 'D'.

  DATA:
    LR_BUDAT TYPE  RANGE OF BKPF-BUDAT,
    LR_KUNNR TYPE  RANGE OF BSEG-KUNNR,
    LR_BUPLA TYPE  RANGE OF BSEG-BUPLA,
    LR_BLART TYPE  RANGE OF BKPF-BLART,
    LR_BELNR TYPE  RANGE OF BKPF-BELNR,
    LR_XBLNR TYPE  RANGE OF BKPF-XBLNR.

  DATA:
    LT_FORMFILE   TYPE  TT_FORMFILE,
    LT_LOG        TYPE  TT_ETAX_LOG,
    LT_FILE_XBLNR TYPE  TT_XBLNR_RANGE.

  DATA:
    LS_DATA     TYPE  TS_ETAX_DATA,
    LS_CUSTOMER TYPE  TS_CUSTOMER,
    LS_REFINPUT TYPE  TS_REFINPUT,
    LS_REFINFO  TYPE  TS_REFINFO.

  DATA:
    LF_ID      TYPE  I,
    LF_VAT_AMT TYPE  TS_ETAX_DATA-VAT_AMT,
    LF_NATION  TYPE  ADRC-NATION,
    LF_SHKZG   TYPE  BSEG-SHKZG,
    LF_COND    TYPE  STRING.               "+20.01.2025

  FIELD-SYMBOLS:
    <L_ETAX_ITEM> TYPE  TS_ETAX_ITEM.


* Initialize Output
  CLEAR: ET_DATA.

* Get Constants
  GET_CONSTANTS( ).

* Get COND/Condition data
  LR_BUDAT  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BUDAT' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_KUNNR  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'KUNNR' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_BUPLA  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BUPLA' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_BLART  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BLART' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_BELNR  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BELNR' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_XBLNR  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BKPF_XBLNR' ]-SELECT_OPTIONS OPTIONAL ) ).

* -----------------
* Get Form File List
* -----------------
  GET_FORM_FILE_LIST(
    EXPORTING
      IF_MODULE   = GC_MODULE_FI
      IF_BUKRS    = IF_BUKRS
      IF_GJAHR    = IF_GJAHR
      IT_DATUM    = LR_BUDAT
    IMPORTING
      ET_FORMFILE = LT_FORMFILE
      ET_XBLNR    = LT_FILE_XBLNR ).

*<-- Start of Insertion 20.01.2025 (Check New/update form flag)
  CLEAR LF_COND.
  IF IF_NEW_FILE IS INITIAL OR
     LT_FILE_XBLNR IS INITIAL.
    LF_COND = 'A~H_BUDAT IN  @LR_BUDAT'.
  ELSE.
    LF_COND = '( A~H_BUDAT IN  @LR_BUDAT OR D~XBLNR   IN  @LT_FILE_XBLNR )'.
  ENDIF.
*--> End of Insertion 20.01.2025

* -----------------
* Get FI Customer Items
* -----------------
  SELECT A~BUKRS,
         A~BELNR,
         A~GJAHR,
         A~BUZEI,
         D~BUDAT,
         D~BLART,
         B~LTEXT AS BLART_TXT,
         A~BUPLA,
         A~KUNNR,
         D~XBLNR,
         A~ZTERM,
         C~VTEXT AS ZTERM_TXT,
         A~UMSKZ,
         A~ZFBDT,
         A~ZBD1T,
         A~ZBD2T,
         A~ZBD3T,
         A~SHKZG,
         A~REBZG,
         A~REBZJ,
         A~REBZZ,
         A~ZUONR,
         A~SGTXT,
         A~KOART,
         A~J_1TPBUPL,
         D~STBLG,
         D~USNAM AS ERNAM,
         D~CPUDT AS ERDAT,
         D~CPUTM AS ERTIM,
         D~AEDAT,
         D~WAERS,
         A~WRBTR AS AMOUNT,
         A~MWSKZ,
*        RD Mapping Fields
         E~DOCTY,
         F~DESCP_TH,
         F~DESCP_EN,
         F~DCGRP,
         H~TAXTY,
         G~*   "BSEC
    FROM BSEG AS A
           INNER JOIN BKPF AS D
             ON  D~BUKRS = A~BUKRS
             AND D~BELNR = A~BELNR
             AND D~GJAHR = A~GJAHR
           INNER JOIN T003T AS B
             ON  B~SPRAS = @SY-LANGU
             AND B~BLART = D~BLART
           INNER JOIN ZSDSSDC026 AS E
             ON  E~BLART = A~H_BLART
             AND E~MWSKZ = A~MWSKZ
           INNER JOIN ZSDSSDC014 AS F
             ON  F~DOCTY = E~DOCTY
           LEFT OUTER JOIN TVZBT AS C
             ON  C~SPRAS = @SY-LANGU
             AND C~ZTERM = A~ZTERM
           LEFT OUTER JOIN ZSDSSDC021 AS H             "#EC CI_BUFFJOIN
             ON  H~MWSKZ = A~MWSKZ
           LEFT OUTER JOIN BSEC AS G
             ON  G~BUKRS = A~BUKRS
             AND G~BELNR = A~BELNR
             AND G~GJAHR = A~GJAHR
             AND G~BUZEI = A~BUZEI
   WHERE A~BUKRS   EQ  @IF_BUKRS
     AND A~GJAHR   EQ  @IF_GJAHR
     AND A~KOART   EQ  @LC_CUSTOMER
     AND A~UMSKZ   IN  @GR_FI_UMSKZ
     AND A~BELNR   IN  @LR_BELNR
*     AND ( A~H_BUDAT IN  @LR_BUDAT OR                                  "-20.01.2025
*           D~XBLNR   IN  @LT_FILE_XBLNR )  "Ignore Date if File found  "-20.01.2025
     AND A~KUNNR   IN  @LR_KUNNR
     AND A~BUPLA   IN  @LR_BUPLA
     AND A~H_BLART IN  @LR_BLART
     AND D~XBLNR   IN  @LR_XBLNR
     AND D~STBLG   EQ  @SPACE
*<-- Start of Insertion 20.01.2025 Ignore Date if File found
     AND (LF_COND)
*--> End of Insertion 20.01.2025
    INTO TABLE @DATA(LT_INV).                           "#EC CI_NOORDER
  IF SY-SUBRC NE 0.
    CLEAR LT_INV.
  ENDIF.

* -----------------
* Get FI Cancel/Reversed Items
* -----------------
  SELECT A~BUKRS,
         A~BELNR,
         A~GJAHR,
         A~BUZEI,
         D~BUDAT,
         D~BLART,
         B~LTEXT AS BLART_TXT,
         A~BUPLA,
         A~KUNNR,
         D~XBLNR,
         A~ZTERM,
         C~VTEXT AS ZTERM_TXT,
         A~UMSKZ,
         A~ZFBDT,
         A~ZBD1T,
         A~ZBD2T,
         A~ZBD3T,
         A~SHKZG,
         A~REBZG,
         A~REBZJ,
         A~REBZZ,
         A~ZUONR,
         A~SGTXT,
         A~KOART,
         A~J_1TPBUPL,
         D~STBLG,
         D~USNAM AS ERNAM,
         D~CPUDT AS ERDAT,
         D~CPUTM AS ERTIM,
         D~AEDAT,
         D~WAERS,
         A~WRBTR AS AMOUNT,
         A~MWSKZ,
*        RD Mapping Fields
         E~DOCTY,
         F~DESCP_TH,
         F~DESCP_EN,
         F~DCGRP,
         H~TAXTY,
         G~*   "BSEC
    FROM BKPF AS X
           INNER JOIN BSEG AS A
             ON  A~BUKRS = X~BUKRS
             AND A~BELNR = X~STBLG
             AND A~GJAHR = X~STJAH
           INNER JOIN BKPF AS D
             ON  D~BUKRS = A~BUKRS
             AND D~BELNR = A~BELNR
             AND D~GJAHR = A~GJAHR
           INNER JOIN T003T AS B
             ON  B~SPRAS = @SY-LANGU
             AND B~BLART = D~BLART
           INNER JOIN ZSDSSDC026 AS E
             ON  E~BLART = D~BLART
             AND E~MWSKZ = A~MWSKZ
           INNER JOIN ZSDSSDC014 AS F
             ON  F~DOCTY = E~DOCTY
           LEFT OUTER JOIN TVZBT AS C
             ON  C~SPRAS = @SY-LANGU
             AND C~ZTERM = A~ZTERM
           LEFT OUTER JOIN ZSDSSDC021 AS H             "#EC CI_BUFFJOIN
             ON  H~MWSKZ = A~MWSKZ
           LEFT OUTER JOIN BSEC AS G
             ON  G~BUKRS = A~BUKRS
             AND G~BELNR = A~BELNR
             AND G~GJAHR = A~GJAHR
             AND G~BUZEI = A~BUZEI
   WHERE X~BUKRS EQ  @IF_BUKRS
     AND X~GJAHR EQ  @IF_GJAHR
     AND X~BELNR IN  @LR_BELNR
     AND X~BUDAT IN  @LR_BUDAT
     AND X~BLART EQ  'DX'
     AND A~KOART EQ  @LC_CUSTOMER
     AND A~UMSKZ IN @GR_FI_UMSKZ
     AND A~KUNNR IN  @LR_KUNNR
     AND A~BUPLA IN  @LR_BUPLA
     AND D~XBLNR IN  @LR_XBLNR
    APPENDING TABLE @LT_INV.
  IF SY-SUBRC NE 0 AND
     LT_INV IS INITIAL.
    RETURN.
  ENDIF.

* Remove SP/GL = Blank if SP/GL = S is found
  LOOP AT LT_INV ASSIGNING FIELD-SYMBOL(<L_INV>)
                 WHERE UMSKZ = 'S'.
    IF <L_INV>-BLART EQ 'DX'.
      LF_SHKZG = 'H'.
    ELSE.
      LF_SHKZG = 'S'.
    ENDIF.

    IF <L_INV>-SHKZG EQ LF_SHKZG.
      DELETE LT_INV.
      CONTINUE.
    ELSE.
      DELETE LT_INV WHERE BUKRS EQ <L_INV>-BUKRS
                      AND BELNR EQ <L_INV>-BELNR
                      AND GJAHR EQ <L_INV>-GJAHR
                      AND UMSKZ EQ SPACE.
    ENDIF.
  ENDLOOP.

* -----------------
* Get FI Items
* -----------------
  SELECT A~BUKRS,
         A~BELNR,
         A~GJAHR,
         A~BUZEI,
         A~BUZID,
         A~HKONT,
         A~KUNNR,
         A~SGTXT,
         A~ZUONR,
         A~UMSKZ,
         A~ZFBDT,
         A~KOART,
         A~MWART,
         A~MWSKZ,
         A~SHKZG,
         A~WRBTR AS AMOUNT,
         A~MENGE,
         A~REBZG,
         A~REBZJ,
         A~REBZZ
    FROM @LT_INV AS X
           INNER JOIN BSEG AS A
             ON  A~BUKRS = X~BUKRS
             AND A~BELNR = X~BELNR
             AND A~GJAHR = X~GJAHR
   WHERE ( A~KOART NE @LC_CUSTOMER OR
           A~UMSKZ NE X~UMSKZ )
*           NOT A~UMSKZ IN @LR_UMSKZ )
     AND ( A~BUZID IS NOT INITIAL OR
           A~KTOSL EQ @SPACE )
    INTO TABLE @DATA(LT_ITEM).
  IF SY-SUBRC NE 0.
    CLEAR LT_ITEM.
  ENDIF.

* -----------------
* Collect Result
* -----------------
  LOOP AT LT_INV ASSIGNING <L_INV>.

    CLEAR LS_DATA.
    MOVE-CORRESPONDING <L_INV> TO LS_DATA ##ENH_OK.
    LS_DATA-SAP_MODULE = GC_MODULE_FI.
    LS_DATA-FKDAT      = <L_INV>-BUDAT.
    LS_DATA-FKART      = <L_INV>-BLART.
    LS_DATA-FKART_TXT  = <L_INV>-BLART_TXT.
*   Mark Cancel Flag for Cancelling Billing
    IF <L_INV>-STBLG IS NOT INITIAL.
      LS_DATA-CANCEL = 'X'.
    ENDIF.

*   Due Date
    CALL FUNCTION 'NET_DUE_DATE_GET'
      EXPORTING
        I_ZFBDT = <L_INV>-ZFBDT
        I_ZBD1T = <L_INV>-ZBD1T
        I_ZBD2T = <L_INV>-ZBD2T
        I_ZBD3T = <L_INV>-ZBD3T
        I_SHKZG = <L_INV>-SHKZG
        I_REBZG = <L_INV>-REBZG
      IMPORTING
        E_FAEDT = LS_DATA-DUEDT.
    IF LS_DATA-DUEDT IS INITIAL.
      LS_DATA-DUEDT = LS_DATA-FKDAT.
    ENDIF.

*   ETax Map Field
    IF LS_DATA-XBLNR IS NOT INITIAL.
      LS_DATA-TAXINV        = LS_DATA-XBLNR.
    ELSE.
      LS_DATA-TAXINV        = LS_DATA-BELNR.
    ENDIF.

*   Read Form File of Tax Invoice
    READ TABLE LT_FORMFILE INTO DATA(LS_FORMFILE)
                           WITH KEY BUKRS = LS_DATA-BUKRS
                                    GJAHR = LS_DATA-GJAHR
                                    DOCTY = LS_DATA-DOCTY
                                    TAXINV = LS_DATA-TAXINV
                           BINARY SEARCH.
    IF SY-SUBRC NE 0.
      CLEAR LS_FORMFILE.
      IF <L_INV>-BUDAT NOT IN LR_BUDAT. "Skip record date not matched
        CONTINUE.
      ENDIF.
    ENDIF.
    LS_DATA-FORM_FNAME = LS_FORMFILE-FORM_FNAME.

*   Get Form Language
    LF_NATION = GET_FORM_LANG( IS_FORMFILE = LS_FORMFILE ).

*   Customer Data
    LS_CUSTOMER = GET_CUSTOMER_INFO( IF_KUNNR     = LS_DATA-KUNNR
                                     IF_J_1TPBUPL = <L_INV>-J_1TPBUPL
                                     IS_BSEC      = <L_INV>-G
                                     IF_NATION    = LF_NATION ).
    LS_DATA-KUNNR_NAME = |{ LS_CUSTOMER-ADRC-NAME1 }{ LS_CUSTOMER-ADRC-NAME2 }{ LS_CUSTOMER-ADRC-NAME3 }{ LS_CUSTOMER-ADRC-NAME4 }|.
    LS_DATA-STCD3      = LS_CUSTOMER-STCD3.
    LS_DATA-BRANCH     = LS_CUSTOMER-J_1TPBUPL.
    LS_DATA-BRANCH_TX  = LS_CUSTOMER-DESCRIPTION.
    LS_DATA-EMAIL      = LS_CUSTOMER-EMAIL.
    LS_DATA-CUST_ADRC  = LS_CUSTOMER-ADRC.
    LS_DATA-CUST_ETAX  = LS_CUSTOMER-ETAX.

*   Tax Data
    LS_DATA-TAXTY = <L_INV>-TAXTY.
    GET_TAX_RATE(
      EXPORTING
        IF_MWSKZ = <L_INV>-MWSKZ
      IMPORTING
        EF_RATE  = LS_DATA-TAXRATE ).

*   Tax Amount
    LOOP AT LT_ITEM ASSIGNING FIELD-SYMBOL(<L_ITEM>)
                    WHERE BUKRS EQ <L_INV>-BUKRS
                      AND BELNR EQ <L_INV>-BELNR
                      AND GJAHR EQ <L_INV>-GJAHR
                      AND BUZID IS NOT INITIAL.
      LS_DATA-VAT_AMT = LS_DATA-VAT_AMT + <L_ITEM>-AMOUNT.
    ENDLOOP.

    IF <L_INV>-DCGRP EQ 'DCN'.
      CLEAR LS_REFINPUT.
      LS_REFINPUT-BUKRS   = <L_INV>-BUKRS.
      LS_REFINPUT-BELNR   = <L_INV>-BELNR.
      LS_REFINPUT-GJAHR   = <L_INV>-GJAHR.
      LS_REFINPUT-BUZEI   = <L_INV>-BUZEI.
      LS_REFINPUT-SGTXT   = <L_INV>-SGTXT.
      LS_REFINPUT-REBZG   = <L_INV>-REBZG.
      LS_REFINPUT-REBZJ   = <L_INV>-REBZJ.
      LS_REFINPUT-REBZZ   = <L_INV>-REBZZ.
      LS_REFINPUT-ERDAT   = <L_INV>-ERDAT.
      LS_REFINPUT-ERTIM   = <L_INV>-ERTIM.
      LS_REFINPUT-SHKZG   = <L_INV>-SHKZG.
      IF  <L_INV>-UMSKZ NE 'S'.
        LOOP AT LT_ITEM ASSIGNING <L_ITEM>
                        WHERE BUKRS EQ <L_INV>-BUKRS
                          AND BELNR EQ <L_INV>-BELNR
                          AND GJAHR EQ <L_INV>-GJAHR
                          AND KOART EQ LC_CUSTOMER
                          AND BUZID IS INITIAL.
          LS_REFINPUT-AMOUNT  = LS_REFINPUT-AMOUNT + <L_ITEM>-AMOUNT.
*         Special Reference Case (Added on 17.06.2025)
          IF <L_ITEM>-UMSKZ EQ 'S' OR
             <L_ITEM>-UMSKZ EQ 'A'.   "Added 08.07.2025
            LS_REFINPUT-UMSKZ   = <L_ITEM>-UMSKZ.
            LS_REFINPUT-ZUONR   = <L_ITEM>-ZUONR.
            LS_REFINPUT-KUNNR   = <L_ITEM>-KUNNR.
            LS_REFINPUT-REBZG   = <L_ITEM>-REBZG.
            LS_REFINPUT-REBZJ   = <L_ITEM>-REBZJ.
            LS_REFINPUT-REBZZ   = <L_ITEM>-REBZZ.
          ENDIF.
        ENDLOOP.
      ENDIF.
      IF LS_REFINPUT-AMOUNT IS INITIAL.
        LS_REFINPUT-AMOUNT  = <L_INV>-AMOUNT.
*       Deduct Tax
        CASE <L_INV>-SHKZG.
          WHEN 'H'.
            LS_REFINPUT-AMOUNT  = LS_REFINPUT-AMOUNT - LS_DATA-VAT_AMT.
          WHEN OTHERS.
            LS_REFINPUT-AMOUNT  = LS_REFINPUT-AMOUNT + LS_DATA-VAT_AMT.
        ENDCASE.
      ENDIF.
*     Get Ref Inv from Item SP-GL A
      IF LS_REFINPUT-REBZG IS INITIAL.
        LOOP AT LT_ITEM ASSIGNING <L_ITEM>
                        WHERE BUKRS EQ <L_INV>-BUKRS
                          AND BELNR EQ <L_INV>-BELNR
                          AND GJAHR EQ <L_INV>-GJAHR
                          AND BUZID IS INITIAL
                          AND MWART NE 'A'
                          AND REBZG IS NOT INITIAL.
          LS_REFINPUT-REBZG = <L_ITEM>-REBZG.
          LS_REFINPUT-REBZJ = <L_ITEM>-REBZJ.
          LS_REFINPUT-REBZZ = <L_ITEM>-REBZZ.
          EXIT.
        ENDLOOP.
      ENDIF.

*     Get Reference Information
      GET_REF_INFO( EXPORTING IS_INPUT   = LS_REFINPUT
                    IMPORTING ES_REFINFO = LS_REFINFO ).
*     Update Reference Info
      LS_DATA-ORG_AMT     = LS_REFINFO-ORG_AMT.
      LS_DATA-DIFF_AMT    = LS_REFINFO-DIFF_AMT.
      LS_DATA-CORRCT_AMT  = LS_REFINFO-CORRCT_AMT.
      IF LS_REFINFO-XBLNR IS NOT INITIAL.
        LS_DATA-REF_TAXINV = LS_REFINFO-XBLNR.
      ELSE.
        LS_DATA-REF_TAXINV = LS_REFINFO-BELNR.
      ENDIF.
      LS_DATA-REF_DOCTY  = LS_REFINFO-DOCTY.
      LS_DATA-REF_ERDAT  = LS_REFINFO-ERDAT.
      IF <L_INV>-J_1TPBUPL IS INITIAL AND
         LS_REFINFO-J_1TPBUPL IS NOT INITIAL.
        LS_DATA-BRANCH     = LS_REFINFO-J_1TPBUPL.
        LS_DATA-BRANCH_TX  = LS_REFINFO-DESCRIPTION.
      ENDIF.
    ENDIF.

*   Item Data
    CLEAR: LF_ID,
           LF_VAT_AMT.
    UNASSIGN <L_ETAX_ITEM>.
    LOOP AT LT_ITEM ASSIGNING <L_ITEM>
                    WHERE BUKRS EQ <L_INV>-BUKRS
                      AND BELNR EQ <L_INV>-BELNR
                      AND GJAHR EQ <L_INV>-GJAHR
                      AND BUZID IS INITIAL
                      AND MWART NE 'A'.

*     Check Not N Item for CN
      IF <L_INV>-BLART IN GR_BLART_CN AND
         <L_ITEM>-UMSKZ EQ 'N'.
        CONTINUE.
      ENDIF.

*     Update Due date from Down Payment Item
      IF <L_ITEM>-UMSKZ EQ 'A'.
        LS_DATA-DUEDT = <L_ITEM>-ZFBDT.
      ENDIF.

      LF_ID = LF_ID + 1.

      INSERT VALUE #( ID = LF_ID )
             INTO TABLE LS_DATA-ITEM
             ASSIGNING <L_ETAX_ITEM>.

*     Order Reason
      IF <L_INV>-DCGRP EQ 'DCN'.
        IF <L_INV>-SHKZG EQ 'S'.
          LS_DATA-CAUSE_CD = 'DBNS99'.
        ELSE.
          LS_DATA-CAUSE_CD = 'CDNS99'.
        ENDIF.
        IF <L_ITEM>-SGTXT IS NOT INITIAL.
          LS_DATA-CAUSE_TX = <L_ITEM>-SGTXT.
        ELSE.
          SELECT SINGLE CAUSE_TX
            FROM ZSDSSDC015
           WHERE CAUSE_CD EQ @LS_DATA-CAUSE_CD
            INTO @LS_DATA-CAUSE_TX.
          IF SY-SUBRC NE 0.
            CLEAR LS_DATA-CAUSE_TX.
          ENDIF.
        ENDIF.
      ENDIF.

      IF <L_INV>-UMSKZ EQ 'S'.
        <L_ETAX_ITEM>-DESCP  = <L_INV>-SGTXT.
        <L_ETAX_ITEM>-GROSS_AMT = <L_INV>-AMOUNT.
        <L_ETAX_ITEM>-VATBS_AMT = <L_INV>-AMOUNT.
        <L_ETAX_ITEM>-NET1_AMT  = <L_ETAX_ITEM>-VATBS_AMT.
      ELSE.
        <L_ETAX_ITEM>-DESCP  = <L_ITEM>-SGTXT.
        <L_ETAX_ITEM>-GROSS_AMT = <L_ITEM>-AMOUNT.
        <L_ETAX_ITEM>-VATBS_AMT = <L_ITEM>-AMOUNT.
        <L_ETAX_ITEM>-NET1_AMT  = <L_ETAX_ITEM>-VATBS_AMT.
      ENDIF.
      IF LS_REFINFO-SPECIAL_REF EQ 'X'.
        <L_ETAX_ITEM>-DESCP  = LS_REFINFO-ITEM_TEXT.
      ENDIF.
      <L_ETAX_ITEM>-WAERS  = LS_DATA-WAERS.

      IF <L_ITEM>-MENGE IS NOT INITIAL.
        <L_ETAX_ITEM>-FKIMG = <L_ITEM>-MENGE.
      ELSE.
        <L_ETAX_ITEM>-FKIMG = 1.
      ENDIF.
*      <L_ETAX_ITEM>-VRKME

      <L_ETAX_ITEM>-TAXTY     = LS_DATA-TAXTY.
      <L_ETAX_ITEM>-TAXRATE   = LS_DATA-TAXRATE.

      <L_ETAX_ITEM>-VAT_AMT   = ( <L_ETAX_ITEM>-VATBS_AMT * <L_ETAX_ITEM>-TAXRATE ) / 100.
      <L_ETAX_ITEM>-NET2_AMT  = <L_ETAX_ITEM>-NET1_AMT  + <L_ETAX_ITEM>-VAT_AMT.

      LF_VAT_AMT = LF_VAT_AMT + <L_ETAX_ITEM>-VAT_AMT.

      LS_DATA-NET1_AMT = LS_DATA-NET1_AMT + <L_ETAX_ITEM>-VATBS_AMT.
*        ALLW_AMT  TYPE  NETWR, "ส่วนลด
*        CHRG_AMT  TYPE  NETWR, "ค่าธรรมเนียม
**       Charge detail
*        CHRG_TAB  TYPE  TT_CHRG_AMT, (รายละเอียดส่วนลด/ค่าธรรมเนียม)

    ENDLOOP.
*   Skip no Item Entry
    IF LS_DATA-ITEM IS INITIAL.
      CONTINUE.
    ENDIF.

*   Amount Fields
    IF <L_INV>-UMSKZ EQ 'S'.
      LS_DATA-NET1_AMT = <L_INV>-AMOUNT.
    ENDIF.
    LS_DATA-NET2_AMT = LS_DATA-NET1_AMT + LS_DATA-VAT_AMT.
    LS_DATA-VATBS_AMT  = LS_DATA-NET1_AMT.
    LS_DATA-GROSS_AMT  = LS_DATA-NET1_AMT.

*   Assign Diff Amount of VAT into last item
    IF <L_ETAX_ITEM> IS ASSIGNED AND
       LF_VAT_AMT NE LS_DATA-VAT_AMT.
      <L_ETAX_ITEM>-VAT_AMT = <L_ETAX_ITEM>-VAT_AMT + ( LS_DATA-VAT_AMT - LF_VAT_AMT ).
    ENDIF.

*   Get Processing Log
    SELECT BUKRS,
           DOCTY,
           TAXINV,
           SEQNO,
           VBELN,
           BELNR,
           GJAHR,
           CANCEL,
           USNAM,
           STDAT,
           STTIM,
           ENDAT,
           ENTIM,
           STATUS,
           MESSAGE
      FROM ZSDSSDT021
     WHERE BUKRS  EQ @LS_DATA-BUKRS
       AND GJAHR  EQ @LS_DATA-GJAHR
       AND DOCTY  EQ @LS_DATA-DOCTY
       AND TAXINV EQ @LS_DATA-TAXINV
     ORDER BY SEQNO DESCENDING
      INTO TABLE @LT_LOG.
    IF SY-SUBRC NE 0.
      CLEAR LT_LOG.
    ENDIF.

*   Read Success Sending Log
    READ TABLE LT_LOG INTO DATA(LS_LOG)
                      WITH KEY STATUS = 'S'
                               CANCEL = LS_DATA-CANCEL.
    IF SY-SUBRC EQ 0.
*     Update Replace Flag
      LS_DATA-REPLC = 'X'.
    ELSE.
      CLEAR LS_LOG.
      IF LS_DATA-CANCEL EQ 'X'.
*       Read Success Sending Log of main TaxInv
        READ TABLE LT_LOG TRANSPORTING NO FIELDS
                          WITH KEY STATUS = 'S'
                                   CANCEL = SPACE.
        IF SY-SUBRC NE 0.
*         Ignore Cancellation without main successfully submitted
          CONTINUE.
        ENDIF.
      ENDIF.
    ENDIF.

    DATA(LF_AEDAT) = <L_INV>-AEDAT.
    IF LF_AEDAT IS INITIAL.
      LF_AEDAT = <L_INV>-ERDAT.
    ENDIF.

    VALIDATE_ETAX_DATA(
      EXPORTING
        IS_DATA     = LS_DATA
        IF_AEDAT    = LF_AEDAT
        IS_FORMFILE = LS_FORMFILE
        IS_LOG      = LS_LOG
      IMPORTING
        EF_MSGTY    = LS_DATA-MSGTY
        EF_MSGTX    = LS_DATA-MSGTX ).

*<-- Start of Insertion 02.01.2025 (Check Only New Entries)
*   Data already submitted, ignore it
    IF IF_NEW EQ 'X' AND
       LS_DATA-REPLC EQ 'X' AND
*      Text-a01: Update after Send EZTax found.
       LS_DATA-MSGTX NE TEXT-A01.
      CONTINUE.
    ENDIF.
*--> End of Insertion 02.01.2025

    INSERT LS_DATA INTO TABLE ET_DATA.

  ENDLOOP.

ENDMETHOD.


METHOD GET_DATA_SD.

  DATA:
    LR_BUDAT  TYPE  RANGE OF BKPF-BUDAT,
    LR_KUNNR  TYPE  RANGE OF BSEG-KUNNR,
    LR_BUPLA  TYPE  RANGE OF BSEG-BUPLA,
    LR_BLART  TYPE  RANGE OF BKPF-BLART,
    LR_BELNR  TYPE  RANGE OF BKPF-BELNR,
    LR_XBLNR1 TYPE  RANGE OF BKPF-XBLNR,
    LR_VKORG  TYPE  RANGE OF VBRK-VKORG,
    LR_VTWEG  TYPE  RANGE OF VBRK-VTWEG,
    LR_FKART  TYPE  RANGE OF VBRK-FKART,
    LR_VBELN  TYPE  RANGE OF VBRK-VBELN,
    LR_XBLNR2 TYPE  RANGE OF VBRK-XBLNR.

  DATA:
    LT_BILL       TYPE  TT_BILL,
    LT_ITEM       TYPE  TT_BILL_ITEM,
    LT_PRICE      TYPE  TT_BILL_PRICE,
    LT_FORMFILE   TYPE  TT_FORMFILE,
    LT_LOG        TYPE  TT_ETAX_LOG,
    LT_FILE_XBLNR TYPE  TT_XBLNR_RANGE.

  DATA:
    LS_DATA     TYPE  TS_ETAX_DATA,
    LS_CUSTOMER TYPE  TS_CUSTOMER.

  DATA:
    LF_CHRG_IND TYPE  CHAR1,
    LF_ID       TYPE  I,
    LF_NATION   TYPE  ADRC-NATION,
    LF_TAXTY    TYPE  TS_BILL_ITEM-TAXTY,
    LF_MWSK1    TYPE  TS_BILL_ITEM-MWSK1,
    LF_COND     TYPE  STRING.               "+20.01.2025


* Initialize Output
  CLEAR: ET_DATA.

* Get Constants
  GET_CONSTANTS( ).

* Get COND/Condition data
  LR_BUDAT  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BUDAT' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_KUNNR  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'KUNNR' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_BUPLA  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BUPLA' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_BLART  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BLART' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_BELNR  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BELNR' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_XBLNR1 = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'BKPF_XBLNR' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_VKORG  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'VKORG' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_VTWEG  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'VTWEG' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_FKART  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'FKART' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_VBELN  = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'VBELN' ]-SELECT_OPTIONS OPTIONAL ) ).
  LR_XBLNR2 = CORRESPONDING #( VALUE #( IT_COND[ PROPERTY = 'VBRK_XBLNR' ]-SELECT_OPTIONS OPTIONAL ) ).

* -----------------
* Get Form File List
* -----------------
  GET_FORM_FILE_LIST(
    EXPORTING
      IF_MODULE   = GC_MODULE_SD
      IF_BUKRS    = IF_BUKRS
      IF_GJAHR    = IF_GJAHR
      IT_DATUM    = LR_BUDAT
    IMPORTING
      ET_FORMFILE = LT_FORMFILE
      ET_XBLNR    = LT_FILE_XBLNR ).

*<-- Start of Insertion 20.01.2025 (Check New/update form flag)
  CLEAR LF_COND.
  IF IF_NEW_FILE IS INITIAL OR
     LT_FILE_XBLNR IS INITIAL.
    LF_COND = 'A~FKDAT  IN  @LR_BUDAT'.
  ELSE.
    LF_COND = '( A~FKDAT  IN  @LR_BUDAT OR A~XBLNR  IN  @LT_FILE_XBLNR )'.
  ENDIF.
*--> End of Insertion 20.01.2025

* -----------------
* Get Billing Data
* -----------------
  SELECT A~VBELN,
         A~BUKRS,
         A~BELNR,
         A~GJAHR,
         A~FKDAT,
         A~KALSM,
         A~VBTYP,
         A~FKART,
         B~VTEXT AS FKART_TXT,
         A~VTWEG,
         A~BUPLA,
         A~KUNRG AS KUNNR,
         A~XBLNR,
         A~ZTERM,
         C~VTEXT AS ZTERM_TXT,
         A~INCO1,
         A~SFAKN,
         A~ERNAM,
         A~ERDAT,
         A~AEDAT,
         A~WAERK AS WAERS,
         A~NETWR,
         A~MWSBK,
         A~KNUMV,
*        Cancellation
         G~VBELN AS CANC_VBELN,
         G~XBLNR AS CANC_XBLNR,
         G~FKDAT AS CANC_FKDAT,
         H~DOCTY AS CANC_DOCTY,
*        RD Mapping Fields
         D~DOCTY,
         E~DESCP_TH,
         E~DESCP_EN,
         E~DCGRP
    FROM VBRK AS A
           INNER JOIN TVFKT AS B
             ON  B~SPRAS = @SY-LANGU
             AND B~FKART = A~FKART
           INNER JOIN ZSDSSDC017 AS D
             ON  D~FKART = A~FKART
           INNER JOIN ZSDSSDC014 AS E
             ON  E~DOCTY = D~DOCTY
           INNER JOIN BKPF AS F
             ON  F~BUKRS = A~BUKRS
             AND F~BELNR = A~BELNR
             AND F~GJAHR = A~GJAHR
           LEFT OUTER JOIN TVZBT AS C                  "#EC CI_BUFFJOIN
             ON  C~SPRAS = @SY-LANGU
             AND C~ZTERM = A~ZTERM
           LEFT OUTER JOIN VBRK AS G
             ON  G~VBELN = A~SFAKN
           LEFT JOIN ZSDSSDC017 AS H
             ON  H~FKART = G~FKART
   WHERE A~BUKRS  EQ  @IF_BUKRS
     AND A~GJAHR  EQ  @IF_GJAHR
     AND A~VBELN  IN  @LR_VBELN
     AND A~VKORG  IN  @LR_VKORG
     AND A~VTWEG  IN  @LR_VTWEG
     AND A~BUPLA  IN  @LR_BUPLA
     AND A~FKART  IN  @LR_FKART
     AND A~XBLNR  IN  @LR_XBLNR2
     AND A~KUNRG  IN  @LR_KUNNR
*     AND ( A~FKDAT  IN  @LR_BUDAT OR                                 "-20.01.2025
*           A~XBLNR  IN  @LT_FILE_XBLNR )  "Ignore Date if File found "-20.01.2025
     AND A~BELNR  IN  @LR_BELNR
     AND A~FKSTO  EQ  @SPACE     "Not Yet Cancelled "VF11 CN
     AND F~BLART  IN  @LR_BLART
     AND F~XBLNR  IN  @LR_XBLNR1
*<-- Start of Insertion 20.01.2025 Ignore Date if File found
     AND (LF_COND)
*--> End of Insertion 20.01.2025
    INTO TABLE @LT_BILL.
  IF SY-SUBRC NE 0.
    RETURN.
  ENDIF.

* -----------------
* Billing Items
* -----------------
  SELECT A~VBELN,
         A~POSNR,
         A~UEPOS,
         A~MATNR,
         A~ARKTX,
         A~FKIMG,
         A~VRKME,
         A~MWSK1,
         A~MWSKZ,
         A~AUGRU_AUFT AS AUGRU,
         E~BEZEI AS AUGRU_TX,
         A~AUBEL,
         A~AUPOS,
         A~KZWI1,
         A~KZWI2,
         A~KZWI3,
         A~KZWI4,
         A~KZWI5,
         A~MWSBP,
         A~NETWR,
         B~BSTKD,
         B~BSTDK,
         C~AUDAT,
         D~TAXTY
    FROM @LT_BILL AS X
           INNER JOIN VBRP AS A
             ON  A~VBELN = X~VBELN
           LEFT OUTER JOIN VBKD AS B
             ON  B~VBELN = A~AUBEL
             AND B~POSNR = '000000'
           LEFT OUTER JOIN VBAK AS C
             ON  C~VBELN = A~AUBEL
           LEFT OUTER JOIN ZSDSSDC021 AS D
             ON  D~MWSKZ = A~MWSK1
           LEFT OUTER JOIN TVAUT AS E                  "#EC CI_BUFFJOIN
             ON  E~SPRAS = @SY-LANGU
             AND E~AUGRU = A~AUGRU_AUFT
    INTO TABLE @LT_ITEM.
  IF SY-SUBRC NE 0.
    CLEAR LT_ITEM.
  ENDIF.

* -----------------
* Get Billing Price
* -----------------
  SELECT X~VBELN,
         A~KPOSN,
         A~STUNR,
         A~ZAEHK,
         A~KSCHL,
         A~WAERS,
         A~KBETR,
         A~WAERK,
         A~KWERT,
*        RD Mapping Fields
         C~DISC_CD,
         C~DESCP_TH,
         C~DESCP_EN
    FROM @LT_BILL AS X
           INNER JOIN PRCD_ELEMENTS AS A
             ON  A~KNUMV = X~KNUMV
           LEFT OUTER JOIN ZSDSSDC018 AS B
             ON  B~KSCHL = A~KSCHL
           LEFT OUTER JOIN ZSDSSDC016 AS C
             ON  C~DISC_CD = B~DISC_CD
    INTO TABLE @LT_PRICE.
  IF SY-SUBRC NE 0.
    CLEAR LT_PRICE.
  ENDIF.

* -----------------
* Collect Result
* -----------------
  LOOP AT LT_BILL ASSIGNING FIELD-SYMBOL(<L_BILL>).

    CLEAR LS_DATA.
    CLEAR LF_ID.

*   Billing Header data
    MOVE-CORRESPONDING <L_BILL> TO LS_DATA ##ENH_OK.
    LS_DATA-SAP_MODULE        = GC_MODULE_SD.
*   Mark Cancel Flag for Cancelling Billing
    IF <L_BILL>-SFAKN IS NOT INITIAL.   "VF11 CN
      LS_DATA-CANCEL = 'X'.             "VF11 CN
    ENDIF.                              "VF11 CN

*   Default Business Place
    LOOP AT GT_DEFT_BUPLA ASSIGNING FIELD-SYMBOL(<L_DEFT_BUPLA>).
      IF <L_BILL>-VTWEG IN <L_DEFT_BUPLA>-VTWEG.
        LS_DATA-BUPLA = <L_DEFT_BUPLA>-BUPLA.
        EXIT.
      ENDIF.
    ENDLOOP.

*   Due date
    CALL FUNCTION 'J_1A_SD_CI_DUEDATE_GET'
      EXPORTING
        IV_VBELN                 = <L_BILL>-VBELN
        IV_ZTERM                 = <L_BILL>-ZTERM
      IMPORTING
        EV_NETDATE               = LS_DATA-DUEDT
      EXCEPTIONS
        FI_DOCUMENT_NOT_FOUND    = 1
        PAYMENT_TERMS_INCOMPLETE = 2
        INVOICE_NOT_FOUND        = 3
        OTHERS                   = 4.
    IF SY-SUBRC <> 0.
      LS_DATA-DUEDT = <L_BILL>-FKDAT.
    ENDIF.

*   ETax Map Field
    LS_DATA-TAXINV        = LS_DATA-XBLNR.
*    IF <L_BILL>-SFAKN IS NOT INITIAL.        "VF11 CN
*      LS_DATA-TAXINV        = LS_DATA-VBELN. "VF11 CN
*    ELSE.                                    "VF11 CN
*      LS_DATA-TAXINV        = LS_DATA-XBLNR. "VF11 CN
*    ENDIF.                                   "VF11 CN

*   Read Form File of Tax Invoice
    READ TABLE LT_FORMFILE INTO DATA(LS_FORMFILE)
                           WITH KEY BUKRS = LS_DATA-BUKRS
                                    GJAHR = LS_DATA-GJAHR
                                    DOCTY = LS_DATA-DOCTY
                                    TAXINV = LS_DATA-TAXINV
                           BINARY SEARCH.
    IF SY-SUBRC NE 0.
      CLEAR LS_FORMFILE.
      IF <L_BILL>-FKDAT NOT IN LR_BUDAT. "Skip record date not matched
        CONTINUE.
      ENDIF.
    ENDIF.
    LS_DATA-FORM_FNAME = LS_FORMFILE-FORM_FNAME.

*   Get Form Language
    LF_NATION = GET_FORM_LANG( IS_FORMFILE = LS_FORMFILE
                               IF_VBELN    = <L_BILL>-VBELN ).

*   Customer Data
    LS_CUSTOMER = GET_CUSTOMER_INFO( IF_KUNNR  = LS_DATA-KUNNR
                                     IF_VBELN  = <L_BILL>-VBELN
                                     IF_NATION = LF_NATION ).
    LS_DATA-KUNNR_NAME = |{ LS_CUSTOMER-ADRC-NAME1 }{ LS_CUSTOMER-ADRC-NAME2 }{ LS_CUSTOMER-ADRC-NAME3 }{ LS_CUSTOMER-ADRC-NAME4 }|.
    LS_DATA-STCD3      = LS_CUSTOMER-STCD3.
    LS_DATA-BRANCH     = LS_CUSTOMER-J_1TPBUPL.
    LS_DATA-BRANCH_TX  = LS_CUSTOMER-DESCRIPTION.
    LS_DATA-EMAIL      = LS_CUSTOMER-EMAIL.
    LS_DATA-CUST_ADRC  = LS_CUSTOMER-ADRC.
    LS_DATA-CUST_ETAX  = LS_CUSTOMER-ETAX.

*   Amount Fields
    LS_DATA-VATBS_AMT  = <L_BILL>-NETWR.
    LS_DATA-NET1_AMT   = <L_BILL>-NETWR.
    LS_DATA-VAT_AMT    = <L_BILL>-MWSBK.

*   Billing Items data
    LOOP AT LT_ITEM ASSIGNING FIELD-SYMBOL(<L_ITEM>)
                    WHERE VBELN EQ <L_BILL>-VBELN.

*     Check Hide Material from GenC
      IF GR_NOSHOW_MATNR IS NOT INITIAL AND
         <L_ITEM>-MATNR IN GR_NOSHOW_MATNR.
        CONTINUE.
      ENDIF.

*     Customer Reference
      IF LS_DATA-BSTKD IS INITIAL AND
         <L_ITEM>-BSTKD IS NOT INITIAL.
        LS_DATA-BSTKD = <L_ITEM>-BSTKD.
      ENDIF.

*     Customer Reference Date
      IF LS_DATA-BSTDK IS INITIAL AND
         <L_ITEM>-BSTDK IS NOT INITIAL.
        LS_DATA-BSTDK = <L_ITEM>-BSTDK.
      ENDIF.

*     Order Reason
      IF LS_DATA-AUGRU IS INITIAL AND
         <L_ITEM>-AUGRU IS NOT INITIAL.
        LS_DATA-AUGRU = <L_ITEM>-AUGRU.
        GET_CAUSE_MAP(
          EXPORTING
            IF_AUGRU    = LS_DATA-AUGRU
            IF_DOCTY    = LS_DATA-DOCTY
          IMPORTING
            EF_CAUSE_CD = LS_DATA-CAUSE_CD
            EF_CAUSE_TX = LS_DATA-CAUSE_TX ).
        IF <L_ITEM>-AUGRU_TX IS NOT INITIAL.
          LS_DATA-CAUSE_TX = <L_ITEM>-AUGRU_TX.
        ENDIF.
      ENDIF.

*     Tax Code
      IF ( LS_DATA-TAXTY IS INITIAL OR
           LS_DATA-TAXTY EQ 'FRE' ) AND
         ( <L_ITEM>-TAXTY IS NOT INITIAL OR
           <L_ITEM>-TAXTY NE LS_DATA-TAXTY ).
        LS_DATA-TAXTY = <L_ITEM>-TAXTY.
        GET_TAX_RATE(
          EXPORTING
            IF_MWSKZ = <L_ITEM>-MWSK1
          IMPORTING
            EF_RATE  = LS_DATA-TAXRATE ).
      ENDIF.

*     Item Data
      IF <L_ITEM>-UEPOS IS NOT INITIAL.
        READ TABLE LS_DATA-ITEM ASSIGNING FIELD-SYMBOL(<L_ETAX_ITEM>)
                                WITH KEY POSNR = <L_ITEM>-UEPOS.
        IF SY-SUBRC NE 0.
          CONTINUE.
        ENDIF.
      ELSE.
        INSERT VALUE #( POSNR = <L_ITEM>-POSNR )
                INTO TABLE LS_DATA-ITEM
                ASSIGNING <L_ETAX_ITEM>.
        LF_ID = LF_ID + 1.
        <L_ETAX_ITEM>-ID    = LF_ID.
        <L_ETAX_ITEM>-MATNR = <L_ITEM>-MATNR.
        <L_ETAX_ITEM>-FKIMG = <L_ITEM>-FKIMG.
        <L_ETAX_ITEM>-VRKME = <L_ITEM>-VRKME.
        <L_ETAX_ITEM>-WAERS = <L_BILL>-WAERS.
        ASSIGN_ITEM_DESCP(
          EXPORTING
            IS_BILL  = <L_BILL>
            IS_ITEM  = <L_ITEM>
            IT_ITEM  = LT_ITEM
          IMPORTING
            EF_DESCP = <L_ETAX_ITEM>-DESCP ).
*       Default Tax info
        LF_TAXTY = <L_ITEM>-TAXTY.
        LF_MWSK1 = <L_ITEM>-MWSK1.
*       Use Tax Info from Child
        LOOP AT LT_ITEM ASSIGNING FIELD-SYMBOL(<L_ITEM_CHILD>)
                        WHERE VBELN EQ <L_ITEM>-VBELN
                          AND UEPOS EQ <L_ITEM>-POSNR
                          AND MWSK1 IS NOT INITIAL.
          LF_TAXTY = <L_ITEM_CHILD>-TAXTY.
          LF_MWSK1 = <L_ITEM_CHILD>-MWSK1.
          EXIT.
        ENDLOOP.
        <L_ETAX_ITEM>-TAXTY = LF_TAXTY.
        GET_TAX_RATE(
          EXPORTING
            IF_MWSKZ = LF_MWSK1
          IMPORTING
            EF_RATE  = <L_ETAX_ITEM>-TAXRATE ).

      ENDIF.

      LOOP AT LT_PRICE ASSIGNING FIELD-SYMBOL(<L_PRICE>)
                       WHERE VBELN EQ <L_BILL>-VBELN
                         AND KPOSN EQ <L_ITEM>-POSNR.

        CLEAR LF_CHRG_IND.

*       Charge
        IF GR_KSCHL_CHARGE IS NOT INITIAL AND
           <L_PRICE>-KSCHL IN GR_KSCHL_CHARGE.
          LF_CHRG_IND = 'X'.
          <L_ETAX_ITEM>-CHRG_AMT = <L_ETAX_ITEM>-CHRG_AMT + <L_PRICE>-KWERT.
          LS_DATA-CHRG_AMT = LS_DATA-CHRG_AMT +  <L_PRICE>-KWERT.
          DATA(LS_CHRG) = VALUE TS_CHRG_AMT( CHRG_IND = LF_CHRG_IND
                                             DISC_CD  = <L_PRICE>-DISC_CD
                                             DESCP_TH = <L_PRICE>-DESCP_TH
                                             CHRG_AMT = <L_PRICE>-KWERT * -1 ).
          COLLECT LS_CHRG INTO LS_DATA-CHRG_TAB.
          COLLECT LS_CHRG INTO <L_ETAX_ITEM>-CHRG_TAB.
        ENDIF.

*       Discount
        IF GR_KSCHL_DISCOUNT IS NOT INITIAL AND
           <L_PRICE>-KSCHL IN GR_KSCHL_DISCOUNT.
          LS_DATA-ALLW_AMT = LS_DATA-ALLW_AMT + ( <L_PRICE>-KWERT * -1 ).
          <L_ETAX_ITEM>-ALLW_AMT  = <L_ETAX_ITEM>-ALLW_AMT  + ( <L_PRICE>-KWERT * -1 ).
          LS_CHRG = VALUE TS_CHRG_AMT( CHRG_IND = LF_CHRG_IND
                                       DISC_CD  = <L_PRICE>-DISC_CD
                                       DESCP_TH = <L_PRICE>-DESCP_TH
                                       CHRG_AMT = <L_PRICE>-KWERT * -1 ).
          COLLECT LS_CHRG INTO <L_ETAX_ITEM>-CHRG_TAB.
        ENDIF.

      ENDLOOP.

*     Item Amount Field
      <L_ETAX_ITEM>-GROSS_AMT = <L_ETAX_ITEM>-GROSS_AMT + <L_ITEM>-KZWI1.
*      <L_ETAX_ITEM>-ALLW_AMT  = <L_ETAX_ITEM>-ALLW_AMT  + ( <L_ITEM>-KZWI2 - <L_ITEM>-KZWI4 ).
*     Check Free Item>
      IF <L_ITEM>-KZWI1 IS INITIAL.
*       Deduct Amount from Header
        LS_DATA-VATBS_AMT  = LS_DATA-VATBS_AMT - <L_ITEM>-NETWR.
        LS_DATA-NET1_AMT   = LS_DATA-NET1_AMT  - <L_ITEM>-NETWR.
      ELSE.
        <L_ETAX_ITEM>-VATBS_AMT = <L_ETAX_ITEM>-VATBS_AMT + <L_ITEM>-NETWR.
        <L_ETAX_ITEM>-NET1_AMT  = <L_ETAX_ITEM>-NET1_AMT  + <L_ITEM>-NETWR.
      ENDIF.

      <L_ETAX_ITEM>-VAT_AMT   = <L_ETAX_ITEM>-VAT_AMT   + <L_ITEM>-MWSBP.
      <L_ETAX_ITEM>-NET2_AMT  = <L_ETAX_ITEM>-NET1_AMT  + <L_ETAX_ITEM>-VAT_AMT.

      CASE <L_BILL>-VBTYP.
        WHEN GC_CN OR GC_DN.
*<-- Start of Deletion 420000653 11.06.2025 (Remove Old Code)
*          SELECT B~VBELN,
*                 B~POSNR,
*                 B~KZWI3,
*                 C~XBLNR,
*                 C~FKDAT,
*                 D~DOCTY
*            FROM VBAP AS A
*                   INNER JOIN VBRP AS B
*                     ON  B~VBELN = A~VGBEL
*                     AND B~POSNR = A~VGPOS
*                   INNER JOIN VBRK AS C
*                     ON  C~VBELN = B~VBELN
*                   LEFT OUTER JOIN ZSDSSDC017 AS D
*                     ON  D~FKART = C~FKART
*           WHERE A~VBELN EQ @<L_ITEM>-AUBEL
*             AND A~POSNR EQ @<L_ITEM>-AUPOS
*           ORDER BY B~VBELN ASCENDING,
*                    B~POSNR ASCENDING
*            INTO @DATA(LS_ORG)
*              UP TO 1 ROWS.
*          ENDSELECT.
*          IF SY-SUBRC EQ 0.
**           Get Total Reference Invoice Amount
*            SELECT SUM( KZWI3 )
*              FROM VBRP
*             WHERE VBELN EQ @LS_ORG-VBELN
*              INTO @DATA(LF_KZWI3).
*            IF SY-SUBRC EQ 0.
*              LS_ORG-KZWI3 = LF_KZWI3.
*            ENDIF.
*            LS_DATA-ORG_AMT  = LS_DATA-ORG_AMT + LS_ORG-KZWI3.
*          ELSE.
*            CLEAR LS_ORG.
*          ENDIF.
*--> End of Deletion 420000653 11.06.2025
*<-- Start of Insertion 420000653 11.06.2025 (Get Ref from Text)
          GET_REF_INFO_SD(
            EXPORTING
              IF_VBELN = <L_ITEM>-VBELN
              IF_AUBEL = <L_ITEM>-AUBEL
              IF_AUPOS = <L_ITEM>-AUPOS
            IMPORTING
              ES_ORG   = DATA(LS_ORG) ).
          LS_DATA-ORG_AMT  = LS_DATA-ORG_AMT + LS_ORG-KZWI3.
*--> End of Insertion 420000653 11.06.2025
          IF <L_BILL>-KALSM IN GR_KALSM_SUBTOT4 AND
             GR_KALSM_SUBTOT4 IS NOT INITIAL.
            LS_DATA-DIFF_AMT = LS_DATA-DIFF_AMT + <L_ITEM>-KZWI4.
          ELSE.
            LS_DATA-DIFF_AMT = LS_DATA-DIFF_AMT + <L_ITEM>-KZWI5.
          ENDIF.
          IF <L_BILL>-VBTYP EQ GC_DN.
*            LS_DATA-CORRCT_AMT     = LS_DATA-CORRCT_AMT + LS_DATA-ORG_AMT + LS_DATA-DIFF_AMT. "-420000653
            LS_DATA-CORRCT_AMT     = LS_DATA-ORG_AMT + LS_DATA-DIFF_AMT. "+420000653
*            <L_ETAX_ITEM>-NET1_AMT = LS_ORG-KZWI3 + <L_ITEM>-KZWI5.
          ELSE.
            LS_DATA-CORRCT_AMT     = LS_DATA-ORG_AMT - LS_DATA-DIFF_AMT.
*            <L_ETAX_ITEM>-NET1_AMT = LS_ORG-KZWI3 - <L_ITEM>-KZWI5.
          ENDIF.

*         Reference Information
          LS_DATA-REF_TAXINV = LS_ORG-XBLNR.
          LS_DATA-REF_DOCTY  = LS_ORG-DOCTY.
          LS_DATA-REF_ERDAT  = LS_ORG-FKDAT.
*         Default Purpose Info
          IF LS_DATA-CAUSE_CD IS INITIAL.
            IF <L_BILL>-VBTYP EQ GC_CN.
              LS_DATA-CAUSE_CD = 'CDNS99'.
            ELSEIF <L_BILL>-VBTYP EQ GC_DN.
              LS_DATA-CAUSE_CD = 'DBNS99'.
            ENDIF.
          ENDIF.
          IF LS_DATA-CAUSE_TX IS INITIAL AND
             LS_DATA-CAUSE_CD IS NOT INITIAL.
            SELECT SINGLE CAUSE_TX
              FROM ZSDSSDC015
             WHERE CAUSE_CD EQ @LS_DATA-CAUSE_CD
              INTO @LS_DATA-CAUSE_TX.
            IF SY-SUBRC NE 0.
              CLEAR LS_DATA-CAUSE_TX.
            ENDIF.
          ENDIF.

*         Amount Fields
          LS_DATA-GROSS_AMT = LS_DATA-CORRCT_AMT.
          LS_DATA-NET1_AMT  = LS_DATA-CORRCT_AMT.
          LS_DATA-DISC_AMT  = LS_DATA-DISC_AMT  + ( <L_ITEM>-KZWI1 - <L_ITEM>-KZWI4 ).
*          LS_DATA-ALLW_AMT  = LS_DATA-ALLW_AMT + ( <L_ITEM>-KZWI2 - <L_ITEM>-KZWI4 ).

*         Item Amount Field
          <L_ETAX_ITEM>-CHRG_AMT  = <L_ITEM>-KZWI5.

*       Cancel Invoice, considered as CN
        WHEN GC_CANC.

          LS_DATA-ORG_AMT  = LS_DATA-ORG_AMT + <L_ITEM>-KZWI3.
          LS_DATA-CORRCT_AMT = 0.
          LS_DATA-DIFF_AMT = LS_DATA-ORG_AMT + LS_DATA-CORRCT_AMT.
          IF <L_BILL>-CANC_XBLNR IS NOT INITIAL.
            LS_DATA-REF_TAXINV = <L_BILL>-CANC_XBLNR.
          ELSE.
            LS_DATA-REF_TAXINV = <L_BILL>-CANC_VBELN.
          ENDIF.
          LS_DATA-REF_DOCTY  = <L_BILL>-CANC_DOCTY.
          LS_DATA-REF_ERDAT  = <L_BILL>-CANC_FKDAT.
*         Default Purpose Info
          IF LS_DATA-CAUSE_CD IS INITIAL.
            LS_DATA-CAUSE_CD = 'CDNS99'.
          ENDIF.
          IF LS_DATA-CAUSE_TX IS INITIAL AND
             LS_DATA-CAUSE_CD IS NOT INITIAL.
            SELECT SINGLE CAUSE_TX
              FROM ZSDSSDC015
             WHERE CAUSE_CD EQ @LS_DATA-CAUSE_CD
              INTO @LS_DATA-CAUSE_TX.
            IF SY-SUBRC NE 0.
              CLEAR LS_DATA-CAUSE_TX.
            ENDIF.
          ENDIF.
*         Amount Fields
          LS_DATA-GROSS_AMT = LS_DATA-CORRCT_AMT.
          LS_DATA-NET1_AMT  = LS_DATA-CORRCT_AMT.
          LS_DATA-DISC_AMT  = LS_DATA-DISC_AMT  + ( <L_ITEM>-KZWI1 - <L_ITEM>-KZWI4 ).

*         Item Amount Field
          <L_ETAX_ITEM>-CHRG_AMT  = <L_ITEM>-KZWI5.

        WHEN OTHERS.
*         Amount Fields
          LS_DATA-GROSS_AMT = LS_DATA-GROSS_AMT + <L_ITEM>-KZWI1.
          LS_DATA-DISC_AMT  = LS_DATA-DISC_AMT  + ( <L_ITEM>-KZWI1 - <L_ITEM>-KZWI4 ).
*          LS_DATA-ALLW_AMT   = LS_DATA-ALLW_AMT + ( <L_ITEM>-KZWI2 - <L_ITEM>-KZWI4 ).

      ENDCASE.

    ENDLOOP.

*   Calculate Grand Total
    LS_DATA-NET2_AMT   = LS_DATA-NET1_AMT + LS_DATA-VAT_AMT.

*   Get Processing Log
    SELECT BUKRS,
           DOCTY,
           TAXINV,
           SEQNO,
           VBELN,
           BELNR,
           GJAHR,
           CANCEL,
           USNAM,
           STDAT,
           STTIM,
           ENDAT,
           ENTIM,
           STATUS,
           MESSAGE
      FROM ZSDSSDT021
     WHERE BUKRS  EQ @LS_DATA-BUKRS
       AND GJAHR  EQ @LS_DATA-GJAHR
       AND DOCTY  EQ @LS_DATA-DOCTY
       AND TAXINV EQ @LS_DATA-TAXINV
     ORDER BY SEQNO DESCENDING
      INTO TABLE @LT_LOG.
    IF SY-SUBRC NE 0.
      CLEAR LT_LOG.
    ENDIF.

*   Read Success Sending Log
    READ TABLE LT_LOG INTO DATA(LS_LOG)
                      WITH KEY STATUS = 'S'
                               CANCEL = LS_DATA-CANCEL.
    IF SY-SUBRC EQ 0.
*     Update Replace Flag
      LS_DATA-REPLC = 'X'.
    ELSE.
      CLEAR LS_LOG.
      IF LS_DATA-CANCEL EQ 'X'.
*       Read Success Sending Log of main TaxInv
        READ TABLE LT_LOG TRANSPORTING NO FIELDS
                          WITH KEY STATUS = 'S'
                                   CANCEL = SPACE.
        IF SY-SUBRC NE 0.
*         Ignore Cancellation without main successfully submitted
          CONTINUE.
        ENDIF.
      ENDIF.
    ENDIF.

    DATA(LF_AEDAT) = <L_BILL>-AEDAT.
    IF LF_AEDAT IS INITIAL.
      LF_AEDAT = <L_BILL>-ERDAT.
    ENDIF.

    VALIDATE_ETAX_DATA(
      EXPORTING
        IS_DATA     = LS_DATA
        IF_AEDAT    = LF_AEDAT
        IS_FORMFILE = LS_FORMFILE
        IS_LOG      = LS_LOG
      IMPORTING
        EF_MSGTY    = LS_DATA-MSGTY
        EF_MSGTX    = LS_DATA-MSGTX ).

*<-- Start of Insertion 02.01.2025 (Check Only New Entries)
*   Data already submitted, ignore it
    IF IF_NEW EQ 'X' AND
       LS_DATA-REPLC EQ 'X' AND
*      Text-a01: Update after Send EZTax found.
       LS_DATA-MSGTX NE TEXT-A01.
      CONTINUE.
    ENDIF.
*--> End of Insertion 02.01.2025

    INSERT LS_DATA INTO TABLE ET_DATA.

  ENDLOOP.

ENDMETHOD.


METHOD GET_FORM_FILE_LIST.

  TYPES: BEGIN OF TS_FILE,
           BUKRS      TYPE  T001-BUKRS,
           GJAHR      TYPE  BKPF-GJAHR,
           DOCTY      TYPE  ZSDSDE_ETAX_DOCTY,
           TAXINV     TYPE  ZSDSDE_ETAX_TAXINVID,
           FORM_FNAME TYPE  STRING,
           AEDAT      TYPE  SY-DATUM,
           AEZET      TYPE  SY-UZEIT,
           LANGU      TYPE  TS_FORMFILE-LANGU,
         END OF TS_FILE.
  TYPES: TT_FILE  TYPE  STANDARD TABLE OF TS_FILE.

  DATA:
    LT_FILELIST TYPE OIUXC_RSFILLST_ITAB,
    LT_FILE     TYPE TT_FILE,
    LT_TEXT     TYPE STANDARD TABLE OF STRING.

  DATA:
    LS_RETURN TYPE  BAPIRET2,
    LS_FILE   TYPE  TS_FILE.

  DATA:
    LF_FILEPATH  TYPE  STRING.


* Initialize Output
  CLEAR: ET_FORMFILE,
         ET_XBLNR.

  LOOP AT GT_INTF_FORM ASSIGNING FIELD-SYMBOL(<L_INTF_FORM>)
                       WHERE SAP_MODULE EQ IF_MODULE.

    CALL METHOD ZCL_SDSCA_FILE_INTERFACE=>GET_FILE_PATH
      EXPORTING
        IF_INTFNO   = <L_INTF_FORM>-INTFNO
      IMPORTING
        EF_FILEPATH = LF_FILEPATH
        ES_RETURN   = LS_RETURN.
    IF LS_RETURN IS NOT INITIAL.
      CONTINUE.
    ENDIF.

    CALL METHOD ZCL_SDSCA_UTILITIES=>GET_APPSV_FILE_LIST
      EXPORTING
        IF_DIRNAME  = LF_FILEPATH
        IF_FILENAME = '*.PDF'
      IMPORTING
        ET_FILELIST = LT_FILELIST.

    LOOP AT LT_FILELIST ASSIGNING FIELD-SYMBOL(<L_FILELIST>).

      CLEAR LT_TEXT.

*     File Format =  B<DOCTY>_<LANGU>_YYYYMMDD_HHMMSS_<BUKRS><TAXINV><GJAHR>.pdf
      SPLIT <L_FILELIST>-NAME AT '_' INTO TABLE LT_TEXT.

*     Get Last Part
      DATA(LF_INDEX) = LINES( LT_TEXT ).
      IF LF_INDEX LT 4.
        CONTINUE.
      ENDIF.
      READ TABLE LT_TEXT ASSIGNING FIELD-SYMBOL(<L_TEXT>)
                         INDEX LF_INDEX.
      IF SY-SUBRC NE 0.
        CONTINUE.
      ENDIF.

      IF LF_INDEX EQ 5.

*       Read Language from Part2
        READ TABLE LT_TEXT INTO DATA(LF_LANGU)
                           INDEX 2.
        IF SY-SUBRC NE 0.
          CLEAR LF_LANGU.
        ENDIF.
      ENDIF.
*     Default Language
      IF LF_LANGU IS INITIAL.
        LF_LANGU = 'TH'.
      ENDIF.

      TRY.

          DATA(LF_LEN)  = STRLEN( <L_TEXT> ).
          DATA(LF_OFFS) = LF_LEN - 8.
          LF_LEN = LF_LEN - 12 ##NUMBER_OK.
          CLEAR LS_FILE.
          LS_FILE-BUKRS      = <L_TEXT>+0(4).
          LS_FILE-GJAHR      = <L_TEXT>+LF_OFFS(4).
          LS_FILE-TAXINV     = <L_TEXT>+4(LF_LEN).
          LS_FILE-FORM_FNAME = |{ <L_FILELIST>-DIRNAME }{ <L_FILELIST>-NAME }|.
          LS_FILE-AEDAT      = <L_FILELIST>-MOD_DATE.
          LS_FILE-AEZET      = |{ <L_FILELIST>-MOD_TIME+0(2) }{ <L_FILELIST>-MOD_TIME+3(2) }{ <L_FILELIST>-MOD_TIME+6(2) }|.
          LS_FILE-LANGU      = LF_LANGU.
        CATCH CX_ROOT ##CATCH_ALL.
          CONTINUE.

      ENDTRY.

*     Filtering By Company & Year
      CHECK LS_FILE-BUKRS EQ IF_BUKRS AND
            LS_FILE-GJAHR EQ IF_GJAHR.

      READ TABLE LT_TEXT ASSIGNING <L_TEXT>
                         INDEX 1.
      IF SY-SUBRC EQ 0 AND
         STRLEN( <L_TEXT> ) GE 2.
        LS_FILE-DOCTY    = <L_TEXT>+1.
      ENDIF.

*     Collect List of TaxInv when date of file in selection range
*     - In case of reprint but nothing changed on billing/fi document
      IF LS_FILE-AEDAT IN IT_DATUM.
*       Collect Taxinv
        DATA(LS_XBLNR) = VALUE TS_XBLNR_RANGE( SIGN   = 'I'
                                               OPTION = 'EQ'
                                               LOW    = LS_FILE-TAXINV ).
        COLLECT LS_XBLNR INTO ET_XBLNR.
      ENDIF.

      INSERT LS_FILE INTO TABLE LT_FILE.

    ENDLOOP.

  ENDLOOP.

* Sort for Processing
  SORT LT_FILE BY BUKRS  ASCENDING
                  GJAHR  ASCENDING
                  DOCTY  ASCENDING
                  TAXINV ASCENDING
                  AEDAT  DESCENDING
                  AEZET  DESCENDING.
  DELETE ADJACENT DUPLICATES FROM LT_FILE COMPARING BUKRS
                                                    GJAHR
                                                    DOCTY
                                                    TAXINV.

  LOOP AT LT_FILE ASSIGNING FIELD-SYMBOL(<L_FILE>).
    INSERT VALUE #( BUKRS = <L_FILE>-BUKRS
                    GJAHR = <L_FILE>-GJAHR
                    DOCTY = <L_FILE>-DOCTY
                    TAXINV = <L_FILE>-TAXINV
                    FORM_FNAME = <L_FILE>-FORM_FNAME
                    AEDAT      = <L_FILE>-AEDAT
                    AEZET      = <L_FILE>-AEZET
                    LANGU      = <L_FILE>-LANGU )
           INTO TABLE ET_FORMFILE.
  ENDLOOP.

ENDMETHOD.


METHOD GET_FORM_LANG.


  DATA:
    LF_OBJKY  TYPE  NAST-OBJKY.

* Initialize Output
  CLEAR: RF_NATION.

* ------------------------------
* Language from Form File info
* ------------------------------
  IF IS_FORMFILE-LANGU IS NOT INITIAL.
    CASE IS_FORMFILE-LANGU.
      WHEN 'TH'.
        RF_NATION = ' '.
      WHEN 'EN'.
        RF_NATION = 'I'.
      WHEN OTHERS.
        RF_NATION = ' '.
    ENDCASE.

* ------------------------------
* Language from SD Output type log
* ------------------------------
  ELSE.
    LF_OBJKY = IF_VBELN.
    SELECT A~SPRAS
      FROM NAST AS A
     WHERE A~KAPPL EQ 'V3'
       AND A~OBJKY EQ @LF_OBJKY
       AND A~VSTAT EQ '1'
     ORDER BY A~DATVR DESCENDING,
              A~UHRVR DESCENDING
      INTO @DATA(LF_SPRAS)
        UP TO 1 ROWS.
    ENDSELECT.
    IF SY-SUBRC NE 0.
      CLEAR LF_SPRAS.
    ENDIF.

    CASE LF_SPRAS.
      WHEN SPACE OR '2'.
        RF_NATION = ' '.
      WHEN 'E'.
        RF_NATION = 'I'.
      WHEN OTHERS.
*       Defaut blank
        RF_NATION = ' '.
    ENDCASE.
  ENDIF.

ENDMETHOD.


METHOD GET_REF_INFO.

  TYPES: BEGIN OF TS_REFTEXT,
           BELNR      TYPE  BKPF-BELNR,
           ORG_AMT    TYPE  TEXT50,
           CORRCT_AMT TYPE  TEXT50,
           DIFF_AMT   TYPE  TEXT50,
         END OF TS_REFTEXT.

  CONSTANTS:
    LC_CUSTOMER      TYPE  BSEG-KOART VALUE 'D'.

  DATA:
    LS_REFINPUT TYPE  TS_REFINPUT,
    LS_REFTEXT  TYPE  TS_REFTEXT.

  DATA:
    LF_FOUND  TYPE  CHAR1 ##NEEDED,
    LF_AMOUNT TYPE  BSEG-WRBTR,
    LF_BELNR  TYPE  BSEG-BELNR.


* Initialize output
  CLEAR ES_REFINFO.

* Get Constants
  GET_CONSTANTS( ).

  DO 1 TIMES.

*   -----------------------
*   Assign Input Info
*   -----------------------
    IF IF_READITEM IS INITIAL.
      LS_REFINPUT = IS_INPUT.
    ELSE.
      SELECT A~BUKRS,
             A~BELNR,
             A~GJAHR,
             A~BUZEI,
             A~SGTXT,
             A~ZUONR,
             A~KUNNR,
             A~REBZG,
             A~REBZJ,
             A~REBZZ,
             B~CPUDT AS ERDAT,
             B~CPUTM AS ERTIM,
             A~SHKZG,
             A~WRBTR AS AMOUNT,
             A~UMSKZ
        FROM BSEG AS A
               INNER JOIN BKPF AS B
                 ON  B~BUKRS = A~BUKRS
                 AND B~BELNR = A~BELNR
                 AND B~GJAHR = A~GJAHR
       WHERE A~BUKRS EQ @IS_INPUT-BUKRS
         AND A~BELNR EQ @IS_INPUT-BELNR
         AND A~GJAHR EQ @IS_INPUT-GJAHR
         AND A~BUZEI EQ @IS_INPUT-BUZEI
       ORDER BY A~BUKRS ASCENDING,
                A~BELNR ASCENDING,
                A~GJAHR ASCENDING,
                A~BUZEI ASCENDING
        INTO @DATA(LS_TEMP)
          UP TO 1 ROWS.
      ENDSELECT.
      IF SY-SUBRC NE 0.
        EXIT.
      ENDIF.
      CLEAR LF_AMOUNT.
      IF LS_TEMP-UMSKZ NE 'S'.
        SELECT A~UMSKZ,
               A~ZUONR,
               A~KUNNR,
               SUM( WRBTR ) AS AMOUNT
          FROM BSEG AS A
         WHERE A~BUKRS EQ @IS_INPUT-BUKRS
           AND A~BELNR EQ @IS_INPUT-BELNR
           AND A~GJAHR EQ @IS_INPUT-GJAHR
           AND A~KOART EQ @LC_CUSTOMER
           AND A~UMSKZ NE @LS_TEMP-UMSKZ
           AND A~BUZID IS INITIAL
           AND A~KTOSL EQ @SPACE
         GROUP BY A~UMSKZ,
                  A~ZUONR,
                  A~KUNNR
         ORDER BY A~UMSKZ ASCENDING,
                  A~ZUONR ASCENDING,
                  A~KUNNR ASCENDING
          INTO TABLE @DATA(LT_AMOUNT).
        IF SY-SUBRC EQ 0.
          LOOP AT LT_AMOUNT ASSIGNING FIELD-SYMBOL(<L_AMOUNT>).
            LF_AMOUNT = LF_AMOUNT + <L_AMOUNT>-AMOUNT.
*           Assign Special Data (17.06.2025)
            IF <L_AMOUNT>-UMSKZ EQ 'S'.
              LS_TEMP-UMSKZ = <L_AMOUNT>-UMSKZ.
              LS_TEMP-ZUONR = <L_AMOUNT>-ZUONR.
              LS_TEMP-KUNNR = <L_AMOUNT>-KUNNR.
            ENDIF.
          ENDLOOP.
          LS_TEMP-AMOUNT = LF_AMOUNT.
        ENDIF.
      ELSE.
*       Clear unused values (17.06.2025)
        CLEAR: LS_TEMP-UMSKZ,
               LS_TEMP-ZUONR,
               LS_TEMP-KUNNR.
      ENDIF.
      IF LF_AMOUNT IS INITIAL.
*       Minus Tax
        SELECT SUM( CASE A~SHKZG WHEN 'S' THEN CAST( A~WRBTR * -1 AS CURR( 23, 2 ) ) ##NUMBER_OK
                               ELSE A~WRBTR
                    END ) AS AMOUNT
          FROM BSEG AS A
         WHERE A~BUKRS EQ @IS_INPUT-BUKRS
           AND A~BELNR EQ @IS_INPUT-BELNR
           AND A~GJAHR EQ @IS_INPUT-GJAHR
           AND A~BUZID IS NOT INITIAL
          INTO @LF_AMOUNT.
        IF SY-SUBRC EQ 0 AND
           LF_AMOUNT IS NOT INITIAL.
          LS_TEMP-AMOUNT = LS_TEMP-AMOUNT + LF_AMOUNT.
        ENDIF.
      ENDIF.
      LS_REFINPUT = CORRESPONDING #( LS_TEMP ).
    ENDIF.

*   -----------------------
*   Get reference from Text
*   -----------------------
    IF LS_REFINPUT-SGTXT(1) EQ '|'.

      TRY.
*         Reference from Item Text
          SPLIT LS_REFINPUT-SGTXT+1 AT '|' INTO LS_REFTEXT-BELNR
                                             LS_REFTEXT-ORG_AMT
                                             LS_REFTEXT-CORRCT_AMT
                                             LS_REFTEXT-DIFF_AMT.
*         Convert Docno to input format
          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
            EXPORTING
              INPUT  = LS_REFTEXT-BELNR
            IMPORTING
              OUTPUT = LS_REFTEXT-BELNR.

*         Get Posting Date
          SELECT A~BUKRS,
                 A~BELNR,
                 A~GJAHR,
                 A~XBLNR,
                 A~BLART,
                 A~BUDAT,
                 A~USNAM AS ERNAM,
                 A~CPUDT AS ERDAT,
                 A~CPUTM AS ERTIM,
                 A~WAERS,
                 B~WRBTR AS ORG_AMT,
                 B~MWSKZ,
                 B~J_1TPBUPL,
                 F~DESCRIPTION,
                 CASE WHEN E~DOCTY IS NOT INITIAL THEN E~DOCTY
                      ELSE H~DOCTY
                 END AS DOCTY
            FROM BKPF AS A
                 INNER JOIN BSEG AS B
                   ON  B~BUKRS = A~BUKRS
                   AND B~BELNR = A~BELNR
                   AND B~GJAHR = A~GJAHR
                   AND B~KOART = @LC_CUSTOMER
                 LEFT OUTER JOIN ZSDSSDC026 AS E
                   ON  E~BLART = A~BLART
                   AND E~MWSKZ = B~MWSKZ
                 LEFT OUTER JOIN FITHA_PBUPL_D_T AS F
                  ON  F~SPRAS     = @SY-LANGU
                  AND F~KUNNR     = B~KUNNR
                  AND F~J_1TPBUPL = B~J_1TPBUPL
               LEFT OUTER JOIN VBRK AS G
                ON  G~VBELN = B~VBELN
               LEFT OUTER JOIN ZSDSSDC017 AS H
                 ON  H~FKART = G~FKART
           WHERE A~BUKRS EQ @LS_REFINPUT-BUKRS
             AND A~BELNR EQ @LS_REFTEXT-BELNR
             AND ( A~CPUDT LT @LS_REFINPUT-ERDAT OR
                   ( A~CPUDT EQ @LS_REFINPUT-ERDAT AND
                     A~CPUTM LT @LS_REFINPUT-ERTIM ) )
             AND B~UMSKZ IN @GR_FI_UMSKZ
           ORDER BY A~GJAHR DESCENDING
            INTO @ES_REFINFO
              UP TO 1 ROWS.
          ENDSELECT.
          IF SY-SUBRC NE 0.
            CLEAR ES_REFINFO.
          ENDIF.

*         Default from Text
          REPLACE ALL OCCURRENCES OF ',' IN LS_REFTEXT-ORG_AMT WITH ''.
          REPLACE ALL OCCURRENCES OF ',' IN LS_REFTEXT-CORRCT_AMT WITH ''.
          REPLACE ALL OCCURRENCES OF ',' IN LS_REFTEXT-DIFF_AMT WITH ''.
          REPLACE ALL OCCURRENCES OF '|' IN LS_REFTEXT-DIFF_AMT WITH ''.
*         Amount Fields
          ES_REFINFO-BUKRS      = LS_REFINPUT-BUKRS.
          ES_REFINFO-BELNR      = LS_REFTEXT-BELNR.
          ES_REFINFO-GJAHR      = LS_REFINPUT-GJAHR.
          ES_REFINFO-ORG_AMT    = LS_REFTEXT-ORG_AMT.
          ES_REFINFO-CORRCT_AMT = LS_REFTEXT-CORRCT_AMT.
          ES_REFINFO-DIFF_AMT   = LS_REFTEXT-DIFF_AMT.

        CATCH CX_ROOT ##CATCH_ALL.
*         Error Refdoc data
          CLEAR ES_REFINFO.

      ENDTRY.
    ENDIF.

*   Check New Logic Activated?
    IF GF_NEW_REF_START IS NOT INITIAL AND
       LS_REFINPUT-ERDAT LT GF_NEW_REF_START.
      EXIT.
    ENDIF.

*   -----------------------
*   Get Special Reference
*   -----------------------
    IF ( LS_REFINPUT-UMSKZ EQ 'S' OR
         LS_REFINPUT-UMSKZ EQ 'A' ) AND
       STRLEN( LS_REFINPUT-ZUONR ) LE 10 AND
       GR_SPECIAL_ZUONR IS NOT INITIAL AND                  "+420000252
       LS_REFINPUT-ZUONR IN GR_SPECIAL_ZUONR.               "+420000252
      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          INPUT  = LS_REFINPUT-ZUONR
        IMPORTING
          OUTPUT = LF_BELNR.
*     Find Reference Doc
      SELECT B~BUKRS,
             B~BELNR,
             B~GJAHR,
             B~XBLNR,
             B~BLART,
             B~BUDAT,
             B~USNAM AS ERNAM,
             B~CPUDT AS ERDAT,
             B~CPUTM AS ERTIM,
             B~WAERS,
             A~WRBTR AS ORG_AMT,
             A~MWSKZ,
             A~J_1TPBUPL,
             F~DESCRIPTION,
             E~DOCTY
        FROM BSEG AS A
               INNER JOIN BKPF AS B
                 ON  B~BUKRS = A~BUKRS
                 AND B~BELNR = A~BELNR
                 AND B~GJAHR = A~GJAHR
               LEFT OUTER JOIN ZSDSSDC026 AS E
                 ON  E~BLART = B~BLART
                 AND E~MWSKZ = A~MWSKZ
               LEFT OUTER JOIN FITHA_PBUPL_D_T AS F
                ON  F~SPRAS     = @SY-LANGU
                AND F~KUNNR     = A~KUNNR
                AND F~J_1TPBUPL = A~J_1TPBUPL
       WHERE A~BUKRS  EQ  @LS_REFINPUT-BUKRS
         AND A~BELNR  EQ  @LF_BELNR
         AND A~KUNNR  EQ  @LS_REFINPUT-KUNNR
         AND A~UMSKZ  EQ  @LS_REFINPUT-UMSKZ
         AND ( B~CPUDT LT @LS_REFINPUT-ERDAT OR
             ( B~CPUDT EQ @LS_REFINPUT-ERDAT AND
               B~CPUTM LT @LS_REFINPUT-ERTIM ) )
        ORDER BY A~GJAHR DESCENDING,
                 A~BUZEI ASCENDING
        INTO @DATA(LS_SPECIAL_REF)
          UP TO 1 ROWS.
      ENDSELECT.
      IF SY-SUBRC EQ 0.
*       Special Reference Found
        ES_REFINFO-BUKRS       = LS_SPECIAL_REF-BUKRS.
        ES_REFINFO-BELNR       = LS_SPECIAL_REF-BELNR.
        ES_REFINFO-GJAHR       = LS_SPECIAL_REF-GJAHR.
        ES_REFINFO-XBLNR       = LS_SPECIAL_REF-XBLNR.
        ES_REFINFO-BLART       = LS_SPECIAL_REF-BLART.
        ES_REFINFO-BUDAT       = LS_SPECIAL_REF-BUDAT.
        ES_REFINFO-ERNAM       = LS_SPECIAL_REF-ERNAM.
        ES_REFINFO-ERDAT       = LS_SPECIAL_REF-ERDAT.
        ES_REFINFO-ERTIM       = LS_SPECIAL_REF-ERTIM.
        ES_REFINFO-WAERS       = LS_SPECIAL_REF-WAERS.
        ES_REFINFO-ORG_AMT     = LS_SPECIAL_REF-ORG_AMT.
        ES_REFINFO-MWSKZ       = LS_SPECIAL_REF-MWSKZ.
        ES_REFINFO-J_1TPBUPL   = LS_SPECIAL_REF-J_1TPBUPL.
        ES_REFINFO-DESCRIPTION = LS_SPECIAL_REF-DESCRIPTION.
        ES_REFINFO-DOCTY       = LS_SPECIAL_REF-DOCTY.
      ELSE.
*       Assign Key data from Input Instead
*       *** Etax will be error in this case since
*       *** there is not reference doc date and doc type
        ES_REFINFO-BUKRS       = LS_REFINPUT-BUKRS.
        ES_REFINFO-BELNR       = LF_BELNR.
      ENDIF.
    ENDIF.

    IF ES_REFINFO IS INITIAL.
*     -------------------------------
*     Get Reference from Ref invoice
*     -------------------------------
      CLEAR LF_FOUND.
      IF LS_REFINPUT-REBZG IS NOT INITIAL.
        SELECT C~BUKRS,
               C~BELNR,
               C~GJAHR,
               C~XBLNR,
               C~BLART,
               C~BUDAT,
               C~USNAM AS ERNAM,
               C~CPUDT AS ERDAT,
               C~CPUTM AS ERTIM,
               C~WAERS,
               B~WRBTR AS ORG_AMT,
               B~MWSKZ,
               B~J_1TPBUPL,
               E~DESCRIPTION,
               CASE WHEN D~DOCTY IS NOT INITIAL THEN D~DOCTY
                    ELSE G~DOCTY
               END AS DOCTY
          FROM BSEG AS B
                 INNER JOIN BKPF AS C
                   ON  C~BUKRS = B~BUKRS
                   AND C~BELNR = B~BELNR
                   AND C~GJAHR = B~GJAHR
                 LEFT OUTER JOIN ZSDSSDC026 AS D
                   ON  D~BLART = C~BLART
                   AND D~MWSKZ = B~MWSKZ
                 LEFT OUTER JOIN FITHA_PBUPL_D_T AS E
                  ON  E~SPRAS     = @SY-LANGU
                  AND E~KUNNR     = B~KUNNR
                  AND E~J_1TPBUPL = B~J_1TPBUPL
                 LEFT OUTER JOIN VBRK AS F
                  ON  F~VBELN = B~VBELN
                 LEFT OUTER JOIN ZSDSSDC017 AS G
                   ON  G~FKART = F~FKART
         WHERE B~BUKRS EQ @LS_REFINPUT-BUKRS
           AND B~BELNR EQ @LS_REFINPUT-REBZG
           AND B~GJAHR EQ @LS_REFINPUT-REBZJ
           AND B~BUZEI EQ @LS_REFINPUT-REBZZ
         ORDER BY BUZEI ASCENDING
          INTO @ES_REFINFO
            UP TO 1 ROWS.
        ENDSELECT.
        IF SY-SUBRC EQ 0.
*         Reference Inv found
          LF_FOUND = 'X'.
        ENDIF.

*     -------------------------------
*     Get Reference from Clearing
*     -------------------------------
      ELSE.
        SELECT C~BUKRS,
               C~BELNR,
               C~GJAHR,
               C~XBLNR,
               C~BLART,
               C~BUDAT,
               C~USNAM AS ERNAM,
               C~CPUDT AS ERDAT,
               C~CPUTM AS ERTIM,
               C~WAERS,
               B~WRBTR AS ORG_AMT,
               B~MWSKZ,
               B~J_1TPBUPL,
               E~DESCRIPTION,
               CASE WHEN D~DOCTY IS NOT INITIAL THEN D~DOCTY
                    ELSE G~DOCTY
               END AS DOCTY
          FROM BSE_CLR AS A
                 INNER JOIN BSEG AS B
                   ON  B~BUKRS = A~BUKRS
                   AND B~BELNR = A~BELNR
                   AND B~GJAHR = A~GJAHR
                   AND B~BUZEI = A~BUZEI
                 INNER JOIN BKPF AS C
                   ON  C~BUKRS = A~BUKRS
                   AND C~BELNR = A~BELNR
                   AND C~GJAHR = A~GJAHR
                 LEFT OUTER JOIN ZSDSSDC026 AS D
                   ON  D~BLART = C~BLART
                   AND D~MWSKZ = B~MWSKZ
                 LEFT OUTER JOIN FITHA_PBUPL_D_T AS E
                  ON  E~SPRAS     = @SY-LANGU
                  AND E~KUNNR     = B~KUNNR
                  AND E~J_1TPBUPL = B~J_1TPBUPL
                 LEFT OUTER JOIN VBRK AS F
                  ON  F~VBELN = B~VBELN
                 LEFT OUTER JOIN ZSDSSDC017 AS G
                   ON  G~FKART = F~FKART
         WHERE A~BUKRS_CLR EQ @LS_REFINPUT-BUKRS
           AND A~BELNR_CLR EQ @LS_REFINPUT-BELNR
           AND A~GJAHR_CLR EQ @LS_REFINPUT-GJAHR
           AND ( A~BUKRS NE @LS_REFINPUT-BUKRS OR
                 A~BELNR NE @LS_REFINPUT-BELNR OR
                 A~GJAHR NE @LS_REFINPUT-GJAHR )
         ORDER BY INDEX_CLR ASCENDING
          INTO @ES_REFINFO
            UP TO 1 ROWS.
        ENDSELECT.
        IF SY-SUBRC EQ 0.
*         Reference Inv found
          LF_FOUND = 'X'.
        ENDIF.
      ENDIF.
    ENDIF.
*<-- Start of Insertion 420000252 19.06.2025 (Special Reference Case)
    IF ( LS_REFINPUT-UMSKZ EQ 'S' OR
         LS_REFINPUT-UMSKZ EQ 'A' ) AND
       STRLEN( LS_REFINPUT-ZUONR ) LE 10 AND
       GR_SPECIAL_ZUONR IS NOT INITIAL AND                  "+420000252
       LS_REFINPUT-ZUONR IN GR_SPECIAL_ZUONR.               "+420000252
      CLEAR: ES_REFINFO-ORG_AMT.
      ES_REFINFO-SPECIAL_REF = 'X'.
*     Text-a03: ลดหนี้เงินมัดจำ inv.
      ES_REFINFO-ITEM_TEXT   = |{ TEXT-A03 }{ ES_REFINFO-BELNR }|.
    ENDIF.
*--> End of Insertion 420000252 19.06.2025
*<-- Start of Deletion 16.05.2025 (Fix Case CN VAT Must be ignored)
*    IF LF_FOUND EQ 'X'.
**     Deduct Tax Amount
*      SELECT SUM( CASE A~SHKZG WHEN 'H' THEN CAST( A~WRBTR * -1 AS CURR( 23, 2 ) ) ##NUMBER_OK
*                             ELSE A~WRBTR
*                  END ) AS AMOUNT
*        FROM BSEG AS A
*       WHERE A~BUKRS EQ @ES_REFINFO-BUKRS
*         AND A~BELNR EQ @ES_REFINFO-BELNR
*         AND A~GJAHR EQ @ES_REFINFO-GJAHR
*         AND A~BUZID IS NOT INITIAL
*        INTO @LF_AMOUNT.
*      IF SY-SUBRC EQ 0 AND
*         LF_AMOUNT IS NOT INITIAL.
*        ES_REFINFO-ORG_AMT = ES_REFINFO-ORG_AMT - LF_AMOUNT.
*      ENDIF.
*    ENDIF.
*--> End of Deletion 16.05.2025
  ENDDO.

* Update Reference Info
  IF ES_REFINFO-BELNR IS NOT INITIAL.
    IF ES_REFINFO-DIFF_AMT IS INITIAL.
      ES_REFINFO-DIFF_AMT    = LS_REFINPUT-AMOUNT.
    ENDIF.
    IF ES_REFINFO-CORRCT_AMT IS INITIAL AND
       ES_REFINFO-ORG_AMT IS NOT INITIAL.
      IF LS_REFINPUT-SHKZG EQ 'S'.
        ES_REFINFO-CORRCT_AMT  = ES_REFINFO-ORG_AMT + ES_REFINFO-DIFF_AMT.
      ELSE.
        ES_REFINFO-CORRCT_AMT  = ES_REFINFO-ORG_AMT - ES_REFINFO-DIFF_AMT.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD GET_TAX_RATE.

  TYPES: BEGIN OF TS_RATE,
           MWSKZ TYPE A003-MWSKZ,
           KBETR TYPE KONP-KBETR,
           KONWA TYPE KONP-KONWA,
         END OF TS_RATE.
  TYPES: TT_RATE TYPE SORTED TABLE OF TS_RATE
                      WITH UNIQUE KEY MWSKZ.

  STATICS:
    LT_RATE  TYPE  TT_RATE.


* Initialize Output
  CLEAR EF_RATE.

  IF LT_RATE IS INITIAL.
    SELECT A~MWSKZ,
           B~KBETR,
           B~KONWA
      FROM A003 AS A
             INNER JOIN KONP AS B                      "#EC CI_BUFFJOIN
               ON  B~KNUMH = A~KNUMH
               AND B~KSCHL = A~KSCHL
     WHERE A~KAPPL EQ 'TX'
       AND A~KSCHL EQ 'MWAS'
       AND A~ALAND EQ 'TH'
      INTO TABLE @LT_RATE.
    IF SY-SUBRC NE 0.
      RETURN.
    ENDIF.
  ENDIF.

  READ TABLE LT_RATE ASSIGNING FIELD-SYMBOL(<L_RATE>)
                     WITH KEY MWSKZ = IF_MWSKZ
                     BINARY SEARCH.
  IF SY-SUBRC NE 0.
    RETURN.
  ENDIF.

* Assign Output
  IF <L_RATE>-KONWA EQ '%'.
    EF_RATE = <L_RATE>-KBETR / 10.
  ELSE.
    EF_RATE = <L_RATE>-KBETR.
  ENDIF.

ENDMETHOD.


METHOD LOCK_PROCESSING.

* Initialize Output
  CLEAR ES_RETURN.

  CALL FUNCTION 'ENQUEUE_EZSDSSDT021'
    EXPORTING
      MODE_ZSDSSDT021 = 'E'
      MANDT           = SY-MANDT
      BUKRS           = IF_BUKRS
      GJAHR           = IF_GJAHR
      DOCTY           = IF_DOCTY
      TAXINV          = IF_TAXINV
    EXCEPTIONS
      FOREIGN_LOCK    = 1
      SYSTEM_FAILURE  = 2
      OTHERS          = 3.
  IF SY-SUBRC <> 0.
    ES_RETURN-TYPE        = 'E'.
    ES_RETURN-ID          = SY-MSGID.
    ES_RETURN-NUMBER      = SY-MSGNO.
    ES_RETURN-MESSAGE_V1  = SY-MSGV1.
    ES_RETURN-MESSAGE_V2  = SY-MSGV2.
    ES_RETURN-MESSAGE_V3  = SY-MSGV3.
    ES_RETURN-MESSAGE_V4  = SY-MSGV4.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY
            NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
            INTO ES_RETURN-MESSAGE.
    RETURN.
  ENDIF.

ENDMETHOD.


METHOD SAVE_PROCESSING_LOG.

  DATA:
    LS_SAVE  TYPE  ZSDSSDT021.


* Assign Log Data
  CLEAR LS_SAVE.
  MOVE-CORRESPONDING IS_LOG TO LS_SAVE.

* Get Latest Seqno
  SELECT MAX( SEQNO )
    FROM ZSDSSDT021
   WHERE BUKRS  EQ @LS_SAVE-BUKRS
     AND GJAHR  EQ @LS_SAVE-GJAHR
     AND DOCTY  EQ @LS_SAVE-DOCTY
     AND TAXINV EQ @LS_SAVE-TAXINV
    INTO @DATA(LF_SEQNO).
  IF SY-SUBRC NE 0.
    CLEAR LF_SEQNO.
  ENDIF.
  LS_SAVE-SEQNO = LF_SEQNO + 1.

* Insert New Log
  INSERT ZSDSSDT021 FROM LS_SAVE.
  IF SY-SUBRC NE 0.
*   Error: Error during insert new log entry.
    MESSAGE E021(ZSDSCA01) RAISING LOG_ERROR.
    RETURN.
  ENDIF.

  COMMIT WORK AND WAIT.

ENDMETHOD.


method SHOW_POPUP.

* Only when Popup Activated in online mode
  IF SY-BATCH EQ 'X' OR
     GF_POPUP IS INITIAL.
    RETURN.
  ENDIF.

  DATA(LREF_OUT) = CL_DEMO_OUTPUT=>NEW( )->BEGIN_SECTION( IF_SECTION ).

  CASE IF_TYPE.
    WHEN GC_JSON.
      LREF_OUT->WRITE_JSON( IS_DATA ).
    WHEN GC_HTML.
      LREF_OUT->WRITE_HTML( IS_DATA ).
    WHEN OTHERS.
      RETURN.
  ENDCASE.

* Display Popup
  LREF_OUT->DISPLAY( ).

endmethod.


METHOD TRANSFORM_DATA_TO_JSON.

  DATA:
    LREF_WRITER TYPE REF TO CL_SXML_STRING_WRITER.


* Initialize Output
  CLEAR: EF_JSON.

* Create Writer Object
  LREF_WRITER = CL_SXML_STRING_WRITER=>CREATE(
    TYPE = IF_SXML=>CO_XT_JSON ).

  TRY.
*   Call Transformation
      CALL TRANSFORMATION (IF_TRANSFORM)
                          SOURCE DATA = IS_DATA
                          RESULT XML LREF_WRITER.
    CATCH CX_ROOT INTO DATA(LREF_ERROR) ##CATCH_ALL.
      DATA(LF_LONGTEXT) = LREF_ERROR->IF_MESSAGE~GET_LONGTEXT( PRESERVE_NEWLINES = ' ' ) ##NEEDED.
      DATA(LF_TEXT)     = LREF_ERROR->IF_MESSAGE~GET_TEXT( ) ##NEEDED.
      IF LF_LONGTEXT IS NOT INITIAL.
        MESSAGE LF_LONGTEXT TYPE 'E' RAISING TRANSFORM_ERROR.
      ELSEIF LF_TEXT IS NOT INITIAL.
        MESSAGE LF_TEXT TYPE 'E' RAISING TRANSFORM_ERROR.
      ELSE.
*       Error: Transformation to JSON error.
        MESSAGE E016(ZSDSCA01) RAISING TRANSFORM_ERROR.
      ENDIF.
      RETURN.
  ENDTRY.

* Assign JSON Output
  EF_JSON = LREF_WRITER->GET_OUTPUT( ).

* Text-i01: Result JSON
  SHOW_POPUP(
    EXPORTING
      IS_DATA = EF_JSON
      IF_TYPE = GC_JSON
      IF_SECTION = TEXT-I01 ).

ENDMETHOD.


METHOD TRANSFORM_JSON_TO_DATA.

* Initialize Output
  CLEAR ES_DATA.

* Text-i02: Response JSON
  SHOW_POPUP(
    EXPORTING
      IS_DATA = IF_JSON
      IF_TYPE = GC_JSON
      IF_SECTION = TEXT-I02 ).

  TRY.
*   Transform Data
      CALL TRANSFORMATION (IF_TRANSFORM)
                          SOURCE XML IF_JSON
                          RESULT DATA = ES_DATA.
    CATCH CX_ROOT INTO DATA(LREF_ERROR) ##CATCH_ALL.
      DATA(LF_LONGTEXT) = LREF_ERROR->IF_MESSAGE~GET_LONGTEXT( PRESERVE_NEWLINES = ' ' ) ##NEEDED.
      DATA(LF_TEXT)     = LREF_ERROR->IF_MESSAGE~GET_TEXT( ) ##NEEDED.
      IF LF_LONGTEXT IS NOT INITIAL.
        MESSAGE LF_LONGTEXT TYPE 'E' RAISING TRANSFORM_ERROR.
      ELSEIF LF_TEXT IS NOT INITIAL.
        MESSAGE LF_TEXT TYPE 'E' RAISING TRANSFORM_ERROR.
      ELSE.
*       Error: Transformation from JSON error.
        MESSAGE E019(ZSDSCA01) RAISING TRANSFORM_ERROR.
      ENDIF.
      RETURN.
  ENDTRY.

ENDMETHOD.


METHOD UNLOCK_PROCESSING.

  CALL FUNCTION 'DEQUEUE_EZSDSSDT021'
    EXPORTING
      MODE_ZSDSSDT021 = 'E'
      MANDT           = SY-MANDT
      BUKRS           = IF_BUKRS
      GJAHR           = IF_GJAHR
      DOCTY           = IF_DOCTY
      TAXINV          = IF_TAXINV.

ENDMETHOD.


METHOD VALIDATE_ETAX_DATA.

  DATA:
    LF_LAST_CHANGE  TYPE  SY-DATUM.


* Initialize Output
  CLEAR: EF_MSGTY,
         EF_MSGTX.

* Find Last Change of Tax Invoice
  IF IF_AEDAT IS NOT INITIAL.
    LF_LAST_CHANGE = IF_AEDAT.
  ENDIF.
  IF IS_FORMFILE-AEDAT GT LF_LAST_CHANGE.
    LF_LAST_CHANGE = IS_FORMFILE-AEDAT.
  ENDIF.

* Processing Fields
  IF IS_LOG IS NOT INITIAL.
    EF_MSGTY = IS_LOG-STATUS.
    EF_MSGTX = IS_LOG-MESSAGE.

    IF IS_LOG-ENDAT LT LF_LAST_CHANGE.
      EF_MSGTY = SPACE.
*     Text-a01: Update after Send EZTax found.
      EF_MSGTX = TEXT-A01.
    ENDIF.
  ELSE.
    IF IS_FORMFILE IS INITIAL.
      EF_MSGTY = 'E'.
*     Text-a02: Cannot find form file.
      EF_MSGTX = TEXT-A02.
    ENDIF.
  ENDIF.

  IF EF_MSGTY IS INITIAL.
*   CN/DN Requires Refdoc
    IF IS_DATA-DCGRP EQ 'DCN'.
      IF IS_DATA-REF_TAXINV IS INITIAL.
        EF_MSGTY = 'E'.
*       Text-e03: Cannot find reference document of CN/DN.
        EF_MSGTX = TEXT-E03.
      ENDIF.
    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD CONVERT_REF_DATE_SD.

  DATA:
    LF_MONTH_TX TYPE TEXT20,
    LF_YEAR     TYPE  NUMC4,
    LF_MONTH    TYPE  NUMC2,
    LF_DATE     TYPE  NUMC2.

* Initialize Output
  CLEAR EF_DATUM.

* --------------------------------------
* Input format must be DD-Mon-YYYY
* --------------------------------------
  TRY.
      SPLIT IF_INPUT AT '-' INTO LF_DATE
                                 LF_MONTH_TX
                                 LF_YEAR.

      TRANSLATE LF_MONTH_TX TO UPPER CASE.

*     Convert Month
      CASE LF_MONTH_TX.
        WHEN 'JAN'.
          LF_MONTH = '01'.
        WHEN 'FEB'.
          LF_MONTH = '02'.
        WHEN 'MAR'.
          LF_MONTH = '03'.
        WHEN 'APR'.
          LF_MONTH = '04'.
        WHEN 'MAY'.
          LF_MONTH = '05'.
        WHEN 'JUN'.
          LF_MONTH = '06'.
        WHEN 'JUL'.
          LF_MONTH = '07'.
        WHEN 'AUG'.
          LF_MONTH = '08'.
        WHEN 'SEP'.
          LF_MONTH = '09'.
        WHEN 'OCT'.
          LF_MONTH = '10'.
        WHEN 'NOV'.
          LF_MONTH = '11'.
        WHEN 'DEC'.
          LF_MONTH = '12'.
      ENDCASE.

    CATCH CX_ROOT ##CATCH_ALL.
*     Error
      RETURN.

  ENDTRY.

* Assign Output
  EF_DATUM = |{ LF_YEAR }{ LF_MONTH }{ LF_DATE }|.

ENDMETHOD.


METHOD GET_NEW_REF_INFO_START.

* Initialize Output
  CLEAR RF_DATUM.

* Get Constants
  GET_CONSTANTS( ).

* Assign Output
  RF_DATUM = GF_NEW_REF_START.

ENDMETHOD.


METHOD GET_REF_INFO_SD.

  TYPES: BEGIN OF TS_REF,
           VBELN TYPE  VBRK-VBELN,
           ORG   TYPE  TS_ORIGINAL_INFO,
         END OF TS_REF.
  TYPES: TT_REF  TYPE SORTED TABLE OF TS_REF
                      WITH UNIQUE KEY VBELN.

  STATICS:
    LT_REF TYPE  TT_REF,
    LS_REF TYPE  TS_REF.

  DATA:
    LT_LINE  TYPE  STANDARD TABLE OF TLINE.

  DATA:
    LS_ORG  TYPE  TS_ORIGINAL_INFO.

  DATA:
    LF_NAME TYPE  THEAD-TDNAME,
    LF_TEXT TYPE  TEXT100.


* Initialize Output
  CLEAR ES_ORG.

* ------------------------------
* Get Reference Invoice data
* ------------------------------
  SELECT B~VBELN,
         B~POSNR,
         B~KZWI3,
         C~XBLNR,
         C~FKDAT,
         D~DOCTY
    FROM VBAP AS A
           INNER JOIN VBRP AS B
             ON  B~VBELN = A~VGBEL
             AND B~POSNR = A~VGPOS
           INNER JOIN VBRK AS C
             ON  C~VBELN = B~VBELN
           LEFT OUTER JOIN ZSDSSDC017 AS D
             ON  D~FKART = C~FKART
   WHERE A~VBELN EQ @IF_AUBEL
     AND A~POSNR EQ @IF_AUPOS
   ORDER BY B~VBELN ASCENDING,
            B~POSNR ASCENDING
    INTO @LS_ORG
      UP TO 1 ROWS.
  ENDSELECT.
  IF SY-SUBRC EQ 0.
*   Get Total Reference Invoice Amount
    SELECT SUM( KZWI3 )
      FROM VBRP
     WHERE VBELN EQ @LS_ORG-VBELN
      INTO @DATA(LF_KZWI3).
    IF SY-SUBRC EQ 0.
      LS_ORG-KZWI3 = LF_KZWI3.
    ENDIF.

*   Assign Output
    ES_ORG = LS_ORG.
    RETURN.

  ENDIF.

* ------------------------------
* Get Reference data from Text
* ------------------------------
* Check Memory
  READ TABLE LT_REF INTO LS_REF
                    WITH KEY VBELN = IF_VBELN
                    BINARY SEARCH.
  IF SY-SUBRC NE 0.
    CLEAR LS_REF.
    LS_REF-VBELN = IF_VBELN.
    LF_NAME = IF_VBELN.
*   Get Ref Inv no
    MC_READ_TEXT 'VBBK' 'ZH26' LF_NAME LT_LINE.
    READ TABLE LT_LINE ASSIGNING FIELD-SYMBOL(<L_LINE>)
                       INDEX 1.
    IF SY-SUBRC EQ 0.
      LS_REF-ORG-XBLNR = <L_LINE>-TDLINE.
    ENDIF.

*   Get Ref Inv Amount
    MC_READ_TEXT 'VBBK' 'ZH27' LF_NAME LT_LINE.
    READ TABLE LT_LINE ASSIGNING <L_LINE>
                       INDEX 1.
    IF SY-SUBRC EQ 0.
      TRY.
          LF_TEXT = <L_LINE>-TDLINE.
*         Remove Grouping
          REPLACE ALL OCCURRENCES OF ',' IN LF_TEXT WITH ''.
          LS_REF-ORG-KZWI3 = LF_TEXT.
        CATCH CX_ROOT ##CATCH_ALL.
*         Conversion Error
          CLEAR LS_REF-ORG-KZWI3.
      ENDTRY.
    ENDIF.

*   Get Ref Inv Date
    MC_READ_TEXT 'VBBK' 'ZH28' LF_NAME LT_LINE.
    READ TABLE LT_LINE ASSIGNING <L_LINE>
                       INDEX 1.
    IF SY-SUBRC EQ 0.
      LF_TEXT = <L_LINE>-TDLINE.
      CONVERT_REF_DATE_SD(
        EXPORTING
          IF_INPUT = LF_TEXT
        IMPORTING
          EF_DATUM = LS_REF-ORG-FKDAT ).
    ENDIF.

*   Default Doc Type
    LS_REF-ORG-DOCTY = 'T02'.

*   Save Into Memory
    INSERT LS_REF INTO TABLE LT_REF.

  ELSE.
*   Clear amount since it is header level
*   which must be used only once
    CLEAR LS_REF-ORG-KZWI3.
  ENDIF.

* Assign Result
  ES_ORG = LS_REF-ORG.

ENDMETHOD.
ENDCLASS.
